<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PopupMenu弹出导致RecyclerView滚动的解决方法]]></title>
    <url>%2Fpost%2F91d5b971.html</url>
    <content type="text"><![CDATA[参考： https://blog.csdn.net/qq_16445551/article/details/70213660 起因这个问题其实一直存在，但是新版本增加了Toolbar收缩之后，就因为这个自动滚动直接导致了Toolbar收缩，现象更为明显。 解决办法参考原文两个解决办法 如果你的应用的最小支持版本达到了Android KitKat 4.4的话，建议使用第一种方法。 简单总结一下： 将support.v7包的PopupMenu换成android.widget.PopupWindow包下的PopupMenu。 对应到AndroidX的话，就是将androidx.appcompat.widget.PopupMenu换成import android.widget.PopupMenu 重写与PopupMenu绑定的AnchorView的requestRectangleOnScreen(Rect rectangle, boolean immediate)方法，并且return false。]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin协程混淆规则]]></title>
    <url>%2Fpost%2F5d88e185.html</url>
    <content type="text"><![CDATA[参考： https://github.com/Kotlin/kotlinx.coroutines/issues/799 起因发布了《人升》新版本后， 线上突然出现了数个Kotlin协程相关的异常。 IllegalStateException: Module with the Main dispatcher is missing. Add dependency providing the Main dispatcher, e.g. ‘kotlinx-coroutines-android’ 而我们肯定是已经依赖了kotlin的协程库的，问题不在于此。 不是很懂为什么在更新的好几天之后才集中爆发这个问题。 查询了一下发现是升级kotlin版本后的混淆bug，要增加几条混淆规则。 混淆规则https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/resources/META-INF/proguard/coroutines.pro 将以下混淆规则加入到项目的混淆规则文件中： 12345678910# ServiceLoader support-keepnames class kotlinx.coroutines.internal.MainDispatcherFactory &#123;&#125;-keepnames class kotlinx.coroutines.CoroutineExceptionHandler &#123;&#125;-keepnames class kotlinx.coroutines.android.AndroidExceptionPreHandler &#123;&#125;-keepnames class kotlinx.coroutines.android.AndroidDispatcherFactory &#123;&#125;# Most of volatile fields are updated with AFU and should not be mangled-keepclassmembernames class kotlinx.** &#123; volatile &lt;fields&gt;;&#125; 然后重新编译打包发版吧~]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#17 | 08/25 接入Firebase、Crashlytics]]></title>
    <url>%2Fpost%2Fbe07a40.html</url>
    <content type="text"><![CDATA[找到实习后，挺长一段时间没更新了。 《人升》的话，最近接入了Crashlytics，更新了金币系统等等。 回忆一下Crashlytics的接入过程~ 为什么选择Crashlytics? 不需要额外权限 而国内很多崩溃统计向的都有不少权限要求，比如友盟统计必须依赖READ_PHONE_STATE等权限。 国内也能访问 是的，虽然Crashlytics属于Firebase，但是并没有用到Google的服务器。 配置简单，不需要额外代码 这一点我也很惊喜，只需要在Gradle文件里进行一些配置。项目代码甚至不需要任何变动。 能直接在Crashlytics后台看到混淆前的堆栈信息 另外除了崩溃分析/管理功能外，其实还能在控制台看到活跃用户统计、用户行为分析、次日留存率、版本情况等等。 查看这些信息感觉很有助于维持更新兴趣~ 总体来讲，感觉Crashlytics很适合独立开发者使用。 接入Firebase以及CrashlyticsCrashlytics已经被并入了Firebase体系，所以要先接入Firebase。 Fabric虽然还能直接加入Crashlytics，但是仅提供支持到2020年3月31号，官网也在建议用户迁移至Firebase。 接入Firebase可以参考官方教程。 流程可以概述为： 创建Firebase项目 注册应用，上传签名的SHA码 这两步在官网跟着流程走就可以，就不详细说明了。 下载 google-services.json放到项目的模块目录（一般是app文件夹里）中。 项目级gradle文件里加入Firebase和Crashlytics配置： 123456789101112131415buildscript &#123; ... repositories &#123; // 加上这两个仓库地址 google() maven &#123; url 'https://maven.fabric.io/public' &#125; &#125; dependencies &#123; classpath 'com.google.gms:google-services:4.3.0' // Google 服务 classpath 'io.fabric.tools:gradle:1.29.0' // Crashlytics 插件 &#125;&#125; 模块级gradle文件里加入： 1234567891011apply plugin: 'com.google.gms.google-services'apply plugin: 'io.fabric'dependencies &#123; ... /** firebase **/ implementation 'com.google.firebase:firebase-core:17.0.0' implementation 'com.crashlytics.sdk.android:crashlytics:2.10.1' &#125; 到这一步为止，其实已经集成完毕了。 （可选）如果你的应用开启了代码混淆的话，建议在proguard-rules.pro文件里加入以下规则，以便拿到混淆前的堆栈信息： 123456# Crashlytics-keepattributes *Annotation*-keepattributes SourceFile,LineNumberTable-keep public class * extends java.lang.Exception-keep class com.crashlytics.** &#123; *; &#125;-dontwarn com.crashlytics.** 测试一下崩溃吧 在相应的地方可以用以下语句制造一个崩溃，然后过几分钟后，前往Firebase的后台查看崩溃信息吧~ 1Crashlytics.getInstance().crash() // 制造一个崩溃 更多玩法更多Crashlytics的用法可以参考官方的页面，比如可以记录try-catch住的异常，自定义一些key-value信息方便分析崩溃等等。]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pray For KyoAni]]></title>
    <url>%2Fpost%2Fc3b7d6d1.html</url>
    <content type="text"><![CDATA[Original Publish 这件事的最恐怖之处在于，既不是意外，也不是群体作案，只是一个恶魔因不明原因想报复就造成了这么大的损伤。 京阿尼在日本动画业界是独树一帜的存在：几乎所有的工作都是内部员工完成，培养自己的原画师，福利制度，以及完全不用担心的作品高质量。只因为一个疯子就损失了大半有生力量。 7月18号，早上看到京阿尼工作室遭纵火的消息。初还不相信，看到死亡1人的时候还觉得不是特别严重。然后看着死亡人数慢慢升到了33人，再后来变成34人遇难。心情非常复杂，难受。又忍不住继续看事件的报道更新，然后继续难受。 一开始是看了《K-ON》接触到了京阿尼，动画演绎的形式让这部音乐题材的漫画焕发了新生。初还觉得不会对音乐类的动画感兴趣，看完感觉真香。原来日常都能演绎得这么温馨有趣！ 后续看了京阿尼的其他作品，无一不是制作精良。生活忙碌之后，虽然有几部京阿尼的番剧还没看，但想着，有京阿尼在，优秀的番剧总会源源不断地产出吧，囤着慢慢看也不迟。但… 希望奇迹能发生，希望不要再有遇难人数增加了。希望我们还能再遇见京阿尼。 也希望各方能依此次事件加强安保，减少、杜绝这种个人恐怖袭击事件。 另外，看到一些幸灾乐祸和道德绑架捐赠者的言论也很是难受。 拿捐赠来说，他人捐赠何方是他人意愿，哪容得你一个外人干预。甚至你可以去呼吁不要捐赠，但请不要恶意评论捐赠者。更何况，我甚至怀疑那些人可曾进行过捐赠。 不过，他们也不会看这些的吧。]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>个人</tag>
        <tag>京阿尼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#15 | 06/16 夜间模式]]></title>
    <url>%2Fpost%2F33771fff.html</url>
    <content type="text"><![CDATA[收到多次需要夜间模式的反馈，就研究了一下要怎么实现~ 本以为需要手动替换Theme，实际上Android已经提供了相应的功能。 实际使用之后才发现，Fragment能实现到和Activity在使用上分辨不出的效果。 依赖首先是依赖，需要使用appcompat：（我这里用的androidx库，support库同理） 1implementation 'androidx.appcompat:appcompat:1.1.0-beta01' 准备资源 Activity的主题要继承自 DayNight 主题 123456&lt;!-- Base application theme. --&gt;&lt;style name="AppTheme" parent="Theme.AppCompat.DayNight"&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 创建values-night文件夹，并在里面放置一份相应的colors.xml 步骤： res文件夹右键 -&gt; New -&gt; New Resource Directory Directory name 输入values-night Resource type 输入values 将原本的colors.xml复制一份到values-night文件夹内。 调整夜间模式内的颜色值。 编程实现切换需要注意的是，这里切换没有考虑到状态的保留。用的是finish+startActivity+动画效果。 一开始使用recreate方法，发现会卡顿一下，而且没有动画效果。 切换按钮的逻辑 判断模式的代码参考了：https://juejin.im/entry/586863f1ac502e006d6f1aa8 12345678910111213141516171819//获取当前的模式，设置相反的模式，这里只使用了，夜间和非夜间模式val currentMode = resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASKval editor = SharedPreferencesUtils.getStatusPreferencesInstance().edit()if (currentMode != Configuration.UI_MODE_NIGHT_YES) &#123; //保存夜间模式状态,Application中可以根据这个值判断是否设置夜间模式 AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES) //ThemeConfig主题配置，这里只是保存了是否是夜间模式的boolean值 editor.putBoolean("isNightMode", true).apply()&#125; else &#123; AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO) editor.putBoolean("isNightMode", false).apply()&#125;val intent = Intent(this, MainActivity::class.java)finish()overridePendingTransition(R.anim.fade_in, R.anim.fade_out)startActivity(intent) 自定义Application的相应逻辑 12345if (SharedPreferencesUtils.getStatusPreferencesInstance().getBoolean("isNightMode", false)) &#123; AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES)&#125; else &#123; AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)&#125; 难点其实，夜间模式的实现并不困难。难的是： 相应的夜间模式颜色配置 切换实现流畅的动画效果 切换实现保留状态 切换后确保所有页面都是夜间模式 我这里是将夜间模式的按钮放在了主页的侧边栏，所以finish之后肯定是唯一一个activity，所以不用考虑残留页面的问题。 保留状态这一点也没有考虑，有需要的话可以参考一下https://juejin.im/entry/58eb498e0ce463005869dd3b 另外还有通过windowAnimation配合recreate的方法，但是实际测试好像动画不会生效。]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git修改已经提交的用户名信息]]></title>
    <url>%2Fpost%2F5d88e185.html</url>
    <content type="text"><![CDATA[参考： https://www.jianshu.com/p/93bb4d049955 最近的一条记录如果只是需要修改最近的一条记录的话，只需要 1git commit --amend --author=&quot;作者名 &lt;邮箱@xxxx.com&gt;&quot; 注意：这里的尖括号是要带上的。 多条记录12345678910# 第一步，（n）代表提交次数git rebase -i HEAD~n# 第二步然后按`i`编辑，把`pick` 改成 `edit`，按&apos;Esc&apos;退出编辑，按`:wq`保存退出# 第三步git commit --amend --author=&quot;作者 &lt;邮箱@xxxx.com&gt;&quot; --no-edit# 第四步（多条记录的话，会跳转到下一条记录，返回第三步）git rebase --continue# 第五步（全部完成后，覆盖远程git记录，危险操作要谨慎操作）git push --force 非常多条记录更改转自网络： 如果是多个修改，那么就需要使用到git filter-branch这个工具来做批量修改为了方便大家使用，封装了一个简单的shell脚本，直接修改[XXX]中的变量为对应的值即可 12345678910111213141516171819202122232425#!/bin/sh git filter-branch --env-filter ' an="$GIT_AUTHOR_NAME"am="$GIT_AUTHOR_EMAIL"cn="$GIT_COMMITTER_NAME"cm="$GIT_COMMITTER_EMAIL" if [ "$GIT_COMMITTER_EMAIL" = "[Your Old Email]" ]then cn="[Your New Author Name]" cm="[Your New Email]"fiif [ "$GIT_AUTHOR_EMAIL" = "[Your Old Email]" ]then an="[Your New Author Name]" am="[Your New Email]"fi export GIT_AUTHOR_NAME="$an"export GIT_AUTHOR_EMAIL="$am"export GIT_COMMITTER_NAME="$cn"export GIT_COMMITTER_EMAIL="$cm"']]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Android]多语言、Google授权登陆]]></title>
    <url>%2Fpost%2F7096aa00.html</url>
    <content type="text"><![CDATA[以此文总结一下《LifeUp》上架 GooglePlay 的全过程~ 多语言App默认会根据系统语言加载不同的字符串资源文件，这是我们实现多语言的基础。 新建资源文件首先是建立相应的资源文件，可以手动建立，也可以用 Android Studio 的选项建立： 右键 res 文件夹选择File–&gt;New–&gt;Android resource file选择 Locale 可以见到下图 选择你要新建的语言，并且改文件名为strings即可。 实际上，就是新建一个value-(语言缩写)的文件夹（简体中文的话就是value-zh），然后在其中放上string.xml文件。 提取代码、Layout中的字符串点击相应的字符串，按下ALT+ENTER，然后选择 Extract string resouces。 然后输入字符串资源的名称，勾选相应的资源文件： 按下确定后，AS就会提取该字符串到资源文件内了，同时代码会被替换成： Context getString(resouceId) 在Layout中操作同理，利用这个操作可以替换掉App内大部分的静态的字符串。 那么需要动态赋值的字符串该怎么办呢？ 字符串资源文件中的变量设置比如我们的字符串需要传入一个整数型变量的话： 1"你已经完成了$&#123;getCount()&#125;个任务" // kotlin的String模板写法 当然，你可以简单地拆分为两个字符串&quot;你已经完成了&quot;和&quot;个任务&quot;，然后 1getString(R.string.string1) + getCount() + getString(R.string.string2) 只是这种写法很不优雅，而且会有些小问题。 getString的时候，会自动去掉取得的字符串头尾的空格，这会让我们不太好控制格式。 特别是英文的时候，经常需要空格隔开。 何况，有些语言我们需要更改语序，这种简单拼接的方法就很不合适。 其实，字符串资源文件里可以用变量占位的方法： %n$md：代表输出的是整数，n代表是第几个参数，设置m的值可以在输出之前放置空格。 %n$ms：代表输出的是字符串，n代表是第几个参数，设置m的值可以在输出之前放置空格。 %n$mf：代表输出的是浮点数，n代表是第几个参数，设置m的值可以控制小数位数，如m=2.2时，输出格式为0.00。 如果只有一个变量的话，可以直接不写前面的“%n”。 m的值为0的话，也可以留空。 比如上面的例子中，可以在资源文件里这样写： 1&lt;string name="task_finish"&gt;你已经完成了%1$d个任务，共%2$d个&lt;/string&gt; 英文就可以： 1&lt;string name="task_finish"&gt;You have already completed %1$d of %2$d tasks&lt;/string&gt; 代码中可以这样传入参数： 12// getCompletedCount() 就对应 %1$d，getTotalCount()对应%2$dgetString(R.string.task_finish,getCompletedCount(),getTotalCount()) 利用这个技巧就能完成整个应用的多语言化了。 多语言切换 参考：https://www.jianshu.com/p/b9e32fad36a2 主要参考的是上面这篇文章，非常感谢原作者，稍作了一些代码更改。 工具类代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import android.content.Context;import android.content.SharedPreferences;import android.content.res.Configuration;import android.content.res.Resources;import android.os.Build;import android.os.LocaleList;import android.text.TextUtils;import android.util.DisplayMetrics;import androidx.annotation.RequiresApi;import com.google.gson.Gson;import java.util.Locale;public class LanguageUtil &#123; /** * 中文 */ public static final Locale LOCALE_CHINESE = Locale.CHINESE; /** * 英文 */ public static final Locale LOCALE_ENGLISH = Locale.ENGLISH; private static final String LOCALE_SP = "LOCALE_SP"; private static final String LOCALE_SP_KEY = "LOCALE_SP_KEY"; public static Locale getLocale(Context context) &#123; SharedPreferences spLocale = context.getSharedPreferences(LOCALE_SP, Context.MODE_PRIVATE); String localeJson = spLocale.getString(LOCALE_SP_KEY, ""); if (TextUtils.isEmpty(localeJson)) return null; Gson gson = new Gson(); return gson.fromJson(localeJson, Locale.class); &#125; private static void setLocale(Context pContext, Locale pUserLocale) &#123; SharedPreferences spLocal = pContext.getSharedPreferences(LOCALE_SP, Context.MODE_PRIVATE); SharedPreferences.Editor edit = spLocal.edit(); String json = new Gson().toJson(pUserLocale); edit.putString(LOCALE_SP_KEY, json); edit.apply(); &#125; public static void clearLocale(Context pContext) &#123; SharedPreferences spLocal = pContext.getSharedPreferences(LOCALE_SP, Context.MODE_PRIVATE); SharedPreferences.Editor edit = spLocal.edit(); edit.putString(LOCALE_SP_KEY, ""); edit.apply(); &#125; public static boolean updateLocale(Context context, Locale locale) &#123; if (needUpdateLocale(context, locale)) &#123; Configuration configuration = context.getResources().getConfiguration(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; configuration.setLocale(locale); &#125; else &#123; configuration.locale = locale; &#125; DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics(); context.getResources().updateConfiguration(configuration, displayMetrics); setLocale(context, locale); return true; &#125; return false; &#125; public static boolean needUpdateLocale(Context pContext, Locale newUserLocale) &#123; return newUserLocale != null &amp;&amp; !getCurrentLocale(pContext).equals(newUserLocale); &#125; public static Locale getCurrentLocale(Context context) &#123; Locale locale; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; //7.0有多语言设置获取顶部的语言 locale = context.getResources().getConfiguration().getLocales().get(0); &#125; else &#123; locale = context.getResources().getConfiguration().locale; &#125; return locale; &#125; public static Context languageWork(Context context) &#123; // 8.0及以上使用createConfigurationContext设置configuration if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; return updateResources(context); &#125; else &#123; return context; &#125; &#125; @RequiresApi(api = Build.VERSION_CODES.O) private static Context updateResources(Context context) &#123; Resources resources = context.getResources(); Locale locale = LanguageUtil.getLocale(context); if (locale == null) &#123; return context; &#125; Configuration configuration = resources.getConfiguration(); configuration.setLocale(locale); configuration.setLocales(new LocaleList(locale)); return context.createConfigurationContext(configuration); &#125;&#125; BaseActivity配置（Kotlin）： 1234override fun attachBaseContext(newBase: Context) &#123; val context = LanguageUtil.languageWork(newBase) super.attachBaseContext(context)&#125; 工具类使用： 1LanguageUtil.updateLocale(context, LanguageUtil.LOCALE_ENGLISH) 注意：切换语言后，之前创建的Activity的语言不会马上切换。这里应该引导用户重启应用，或者是想方设法让之前的Activity销毁重建一遍。 接入Google登陆 科学上网肯定是要需要的~这里不提供解决方案。 准备阶段 Google Develper原文：https://developers.google.com/identity/sign-in/android/start-integrating 配置 Android 设备至少是Android 4.1及以上，并且安装有15.0.0以上版本的 Google Play 服务。 项目配置编译版本对应Android 4.1及以上。 安装 Google Play Services SDK 在Android Studio，选择Tools &gt; Android &gt; SDK Manager。 移到底部选择 Extras &gt; Google Repository Gradle配置项目级别的build.gradle文件中配置Google的Maven仓库： 12345678910allprojects &#123; repositories &#123; google() // 如果你使用的Gradle版本低于4.1，使用下面语句代替: // maven &#123; // url 'https://maven.google.com' // &#125; &#125;&#125; 然后在app模块级别的build.gradle文件里，声明Google Play服务依赖： 123456apply plugin: &apos;com.android.application&apos; ... dependencies &#123; compile &apos;com.google.android.gms:play-services-auth:16.0.1&apos; &#125; 配置 Google API 控制台项目点击原文中的CONFIGURE A PROJECT按钮，然后按照步骤进行就可以配置项目了。 或者前往https://console.developers.google.com/apis/配置也可以。 所需的信息 项目名 签名证书的指纹 可以通过这条命令获取： 1keytool -exportcert -keystore &lt;将这里替换成你的keystore文件路径，不含尖括号&gt; -list -v 软件包名 获得Client ID配置完后，你能在Google APIs看到你配置的OAuth 2.0客户端ID。 其中有一个是Web应用类型的，一个是Android应用类型的。 前者是提供给有后端服务器验证需求使用的，具体可以参考：https://developers.google.com/identity/sign-in/android/backend-auth 项目配置实现Google登录配置 GoogleSignInClient直接看代码吧： 在activity的onCreate方法中使用 GoogleSignInOptions 配置你所需要申请的 API 范围： 12345// 配置获取用户ID、邮箱和头像等基础信息// 其中 DEFAULT_SIGN_IN 用户ID和头像等基础信息。GoogleSignInOptions gso = new GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN) .requestEmail() .build(); 同样在onCreate方法中构建一个 GoogleSIgnInClient 实例 12// 利用你刚才的gso配置构建GoogleSIgnInClient实例mGoogleSignInClient = GoogleSignIn.getClient(this, gso); 检查登录状态12345// 检查用户是否已经登录过，如果已经登陆过会返回一个GoogleSignInAccount实例// 接着你就应该拿着这些信息去更新 UI 了// 如果没有登录，account会返回null值。GoogleSignInAccount account = GoogleSignIn.getLastSignedInAccount(this);updateUI(account); 布局增加登录按钮 在布局文件中加入： 1234&lt;com.google.android.gms.common.SignInButton android:id="@+id/sign_in_button" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; 你能得到一个这样的登录按钮： 可选：你可以使用setSize方法修改按钮的样式： 123// 设置登录按钮的尺寸样式SignInButton signInButton = findViewById(R.id.sign_in_button);signInButton.setSize(SignInButton.SIZE_STANDARD); 设置onClickListener： 1findViewById(R.id.sign_in_button).setOnClickListener(this); 实现登录逻辑 实现 activity 的onClick方法： 123456789@Overridepublic void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.sign_in_button: signIn(); break; // ... &#125;&#125; 实现 signIn 方法： 1234private void signIn() &#123; Intent signInIntent = mGoogleSignInClient.getSignInIntent(); startActivityForResult(signInIntent, RC_SIGN_IN);&#125; 在用户登录成功后，你会在activity的onActivityResult 方法回调中获得一个 GoogleSignInAccount实例。 12345678910@Overridepublic void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); // 结果是从 GoogleSignInClient.getSignInIntent(...) 回调回来的; if (requestCode == RC_SIGN_IN) &#123; Task&lt;GoogleSignInAccount&gt; task = GoogleSignIn.getSignedInAccountFromIntent(data); handleSignInResult(task); &#125;&#125; 处理GoogleSignInAccount实例： 1234567891011121314private void handleSignInResult(Task&lt;GoogleSignInAccount&gt; completedTask) &#123; try &#123; GoogleSignInAccount account = completedTask.getResult(ApiException.class); // 登录成功，更新UI // 可以通过account.getId()获取Id，account.getDisplayName获得昵称等 updateUI(account); &#125; catch (ApiException e) &#123; // ApiException 的状态码代表着错误原因 // 可以参考 GoogleSignInStatusCodes 类查询具体原因 Log.w(TAG, "signInResult:failed code=" + e.getStatusCode()); updateUI(null); &#125;&#125; 可选：如果你需要让后端去调用相应API，应该通过 1String idToken = account.getIdToken(); 获取到 IdToken 然后通过HTTP POST方法发送给后端，然后后端拿去验证，调用API。 具体参考：https://developers.google.com/identity/sign-in/android/backend-auth 完整登录代码（Kotlin)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class LoginActivity : BaseActivity() &#123; private lateinit var mGoogleSignInClient: GoogleSignInClient private val RC_SIGN_IN = 416 override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) ... // 登录配置 val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN) .build() mGoogleSignInClient = GoogleSignIn.getClient(this, gso) sign_in_button.setOnClickListener &#123; signInViaGoogle() &#125; &#125; private fun signInViaGoogle() &#123; // 发起登录的Intent val signInIntent = mGoogleSignInClient.signInIntent startActivityForResult(signInIntent, RC_SIGN_IN) &#125; override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; super.onActivityResult(requestCode, resultCode, data) if (requestCode == RC_SIGN_IN) &#123; // 回调收到结果 val task = GoogleSignIn.getSignedInAccountFromIntent(data) handleSignInResult(task) &#125; &#125; private fun handleSignInResult(completedTask: Task&lt;GoogleSignInAccount&gt;) &#123; try &#123; // 拿到结果去更新UI，发起网络请求 val account = completedTask.getResult(ApiException::class.java) val signUpVO = SignUpVO() with(signUpVO) &#123; authIdentifier = account?.id authType = "google" nickname = account?.displayName userHead = account?.photoUrl.toString() idToken = account?.idToken &#125; loginNetworkImpl.loginOrSignUp(signUpVO, "google") &#125; catch (e: ApiException) &#123; Log.w("SIGN", "signInResult:failed code=" + e.statusCode()) &#125; &#125;]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toolbar减少标题和 Navigation icon 的间距]]></title>
    <url>%2Fpost%2F96ecb474.html</url>
    <content type="text"><![CDATA[Toolbar 默认配置下，标题和Navigation icon（比如返回按钮）之间的间隔会迷之过长， 可以通过配置toolbar的属性调整： 1app:contentInsetStartWithNavigation="0dp" 这个间隔的设计好像是配合没有Navigation icon的情况的，默认值为16dp。 有Navigation icon的情况下应该手动调整。 完整的Toolbar配置： 1234567891011121314&lt;com.google.android.material.appbar.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/AppTheme.AppBarOverlay"&gt; &lt;androidx.appcompat.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" app:contentInsetStartWithNavigation="0dp" app:popupTheme="@style/AppTheme.PopupOverlay" /&gt;&lt;/com.google.android.material.appbar.AppBarLayout&gt;]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桌面小部件-IntentService-Oreo的那些事]]></title>
    <url>%2Fpost%2F5e0f1c47.html</url>
    <content type="text"><![CDATA[简介之前在《人升》的桌面小部件，实现ListView中的点击事件监听的方式是： 使用fillInIntent发送广播到Widget类中，并在onReceive方法中拦截，处理业务逻辑。 但是， Widget的本质是个广播接收器，不适宜在里面处理耗时操作。 （完成团队事项的时候需要发送网络请求，普通事项需要更改数据库，都可以视为是耗时操作。） 所以，我决定改用IntentService处理完成事项的业务逻辑。 IntentService的特点是后台运行、自动销毁、异步运行。 首先尝试直接用fillInIntent启动服务失败了。 然后改成了先发送广播，然后在Widget类中，并在onReceive方法拦截再启动IntentService： 123456789101112131415161718192021222324override fun onReceive(context: Context, intent: Intent) &#123; super.onReceive(context, intent) if (...) &#123; ... &#125; else if (intent.action == FINISH_TASK) &#123; // 将耗时操作交给IntentService完成 val finishIntent = Intent(context, FinishTaskIntentService::class.java) if (intent.extras != null) &#123; finishIntent.putExtras(intent.extras!!) &#125; try &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; context.startForegroundService(finishIntent) &#125; else &#123; context.startService(finishIntent) &#125; &#125; catch (e: Exception) &#123; e.printStackTrace() ToastUtils.showShortToast("完成事项似乎出现了一些问题，请尝试刷新下。", LifeUpApplication.getLifeUpApplication()) &#125; &#125;&#125; 然后就遇到了坑。 问题一开始我是没写对Oreo的判断的，直接startService。 简单测试了成功，但是应用放置一会后，再测试，会发现应用抛出了异常： 1java.lang.IllegalStateException: Not allowed to start service Intent 查询了一下，是Oreo不允许后台启动服务。 首先需要以startForegroundService的方式启动服务，然后启动后5s内切换到前台服务（调用startForeground方法）： 12345678910111213141516171819202122232425262728293031323334class FinishTaskIntentService : IntentService("FinishTaskIntentService") &#123; override fun onCreate() &#123; super.onCreate() Log.i("FinishTaskIntentService", "onCreate()") &#125; override fun onHandleIntent(intent: Intent?) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; val NOTIFICATION_CHANNEL_ID = "net.sarasarasa.lifeup" val channelName = "FinishTaskIntentService" val channel = NotificationChannel(NOTIFICATION_CHANNEL_ID, channelName, NotificationManager.IMPORTANCE_MIN) val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager manager.createNotificationChannel(channel) val notification = Notification.Builder(applicationContext, NOTIFICATION_CHANNEL_ID).build() startForeground(1001, notification) &#125; val extras = intent?.extras if (extras != null) &#123; ... // 业务逻辑 &#125; &#125;&#125; 一开始我是直接new Notification传参，然后测试发现又抛了一个异常： 1Bad notification for startForeground: java.lang.RuntimeException: invalid channel for service notification: Notification 嗯，这是Android 8.1新添加的限制。 在Android 8.1中，必须创建自己的Notification Channel。 在 Android 9（P）中，还需要声明前台服务权限： 1&lt;uses-permission android:name="android.permission.FOREGROUND_SERVICE" /&gt; JobIntentService其实 Google 推荐的是使用 JobIntentService 处理那些后台业务。 特色： 8.0以下会被当作普通的Service。 8.0及以上会被作为job用jobScheduler.enqueue()方法来分发。 但是呢，JobIntentService 并不适用于我们这个场景： 它的任务会在合适的时刻执行，（即使空闲）也并不保证会立即执行。 这里的讨论挺有意思的，可以看看~ 结论就是，需要立即执行的业务最好还是靠前台Service实现。 参考https://stackoverflow.com/questions/46445265/android-8-0-java-lang-illegalstateexception-not-allowed-to-start-service-inten JobIntentService详解及使用]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现Snackbar弹出时任意View闪躲]]></title>
    <url>%2Fpost%2F4f03117d.html</url>
    <content type="text"><![CDATA[简介Snackbar 是一个底部弹出消息的控件，类似Toast。 基本使用： 123Snackbar.make(view, message_text, duration) .setAction(action_text, click_listener) .show(); 我们知道，在根布局是CoordinatorLayout，并且设置CoordinatorLayout的behavior之后，可以实现Snackbar弹出的时候，fab（浮动按钮）会自动向上移动防止被遮挡。 代码如下： 布局文件 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/coordinator_layout" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/background_color" &lt;!-- 注意这里要设置 layout_behavior --&gt; app:layout_behavior="@string/appbar_scrolling_view_behavior" tools:context=".fragment.TodoFragment"&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!-- 其他View的布局 --&gt; ... &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="end|bottom" android:layout_marginEnd="16dp" android:layout_marginBottom="16dp" android:adjustViewBounds="false" android:clickable="true" app:backgroundTint="@color/blue" app:fabSize="normal" app:srcCompat="@drawable/ic_add_d" /&gt;&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 注：我这里用了AndroidX的支持库，如果你没迁移到AndroidX，需要改下控件的引用路径。 然后在activity中： 12Snackbar.make(coordinator_layout, "Snackbar弹出信息", Snackbar.LENGTH_SHORT) .show(); 效果（其实这里已经实现了ConstraintLayout的闪躲）： 实现任意View闪躲那么如何实现任意View的闪躲呢？ 查了一番StackOverflow，发现最佳的实践应该就是实现一个通用的behavior。 废话不多说，直接上代码（Java）： 1234567891011121314151617181920212223242526272829@Keeppublic class MoveUpwardBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123; public MoveUpwardBehavior() &#123; super(); &#125; public MoveUpwardBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123; return dependency instanceof Snackbar.SnackbarLayout; &#125; @Override public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) &#123; float translationY = Math.min(0, ViewCompat.getTranslationY(dependency) - dependency.getHeight()); child.setTranslationY(translationY); return true; &#125; // 重写这个方法才能实现滑动清除消息 @Override public void onDependentViewRemoved(CoordinatorLayout parent, View child, View dependency) &#123; ViewCompat.animate(child).translationY(0).start(); &#125;&#125; 然后在布局文件中，在你想要实现闪躲的View上增加这个layout_behavior： 12345678910&lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width="match_parent" android:layout_height="match_parent" &lt;!-- 就是这句了，注意要有完整的包名 --&gt; app:layout_behavior="net.sarasarasa.lifeup.base.MoveUpwardBehavior"&gt; &lt;!-- 其他View的布局 --&gt; ...&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 可以在AS里快速获取含完整报名的引用：右键你的类文件，选择Copy Reference。 没错，这样就完成了~测试去吧。 参考https://stackoverflow.com/questions/33217241/how-to-move-a-view-above-snackbar-just-like-floatingbutton]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2+Jpa+Shiro实现用户鉴权]]></title>
    <url>%2Fpost%2F27139efb.html</url>
    <content type="text"><![CDATA[课设有个额外任务是用Shiro实现用户鉴权，记录一下。 大部分步骤都参考了 https://xlui.me/t/spring-boot-shiro/ 这篇文章，安利一下~ 不过也遇到了一些小问题。 添加依赖或是添加以下 Maven 依赖 123456&lt;!-- shiro --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; 建表和实体类Sql语句建表 123456789101112131415161718192021222324252627282930313233343536373839404142434445DROP TABLE IF EXISTS `shiro_permission`;CREATE TABLE `shiro_permission` ( `permission_id` int(10) NOT NULL AUTO_INCREMENT, `permission` varchar(128) NOT NULL, `create_time` datetime(6) DEFAULT NULL, `remark` varchar(1000) DEFAULT NULL, PRIMARY KEY (`permission_id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `shiro_role`;CREATE TABLE `shiro_role` ( `role_id` int(10) NOT NULL AUTO_INCREMENT, `role` varchar(128) NOT NULL, `create_time` datetime(6) NOT NULL, `remark` varchar(1000) DEFAULT NULL, PRIMARY KEY (`role_id`)) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `shiro_role_permission`;CREATE TABLE `shiro_role_permission` ( `rp_id` int(10) NOT NULL AUTO_INCREMENT, `permission_id` int(128) NOT NULL, `role_id` int(128) NOT NULL, PRIMARY KEY (`rp_id`)) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `shiro_user`;CREATE TABLE `shiro_user` ( `user_id` int(10) NOT NULL AUTO_INCREMENT, `password` varchar(128) NOT NULL, `salt` varchar(128) NOT NULL, `username` varchar(64) NOT NULL, `nickname` varchar(128) DEFAULT NULL, `create_time` datetime(6) NOT NULL, `remark` varchar(1000) DEFAULT NULL, PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;DROP TABLE IF EXISTS `shiro_user_role`;CREATE TABLE `shiro_user_role` ( `ur_id` int(10) NOT NULL AUTO_INCREMENT, `user_id` int(128) NOT NULL, `role_id` int(128) NOT NULL, PRIMARY KEY (`ur_id`)) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8; PermissionDO.java 123456789101112131415161718192021222324252627282930313233343536373839404142package net.sarasarasa.dataobject;import lombok.Data;import javax.persistence.*;import java.io.Serializable;import java.util.Date;import java.util.List;/** * @author AyagiKei * @url https://github.com/Ayagikei **/@Data@Entity@Table(name = "shiro_permission")public class PermissionDO implements Serializable &#123; private static final long serialVersionUID = -2815922618943120009L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = "permission_id") private Integer permissionId; private String permission; // 创建时间 @Column(name = "create_time") private Date createTime; private String remark; @ManyToMany @JoinTable(name = "shiro_role_permission", joinColumns = &#123;@JoinColumn(name = "permission_id")&#125;, inverseJoinColumns = &#123;@JoinColumn(name = "role_id")&#125;) private List&lt;RoleDO&gt; roleList; @Override public String toString() &#123; return permission; &#125;&#125; RoleDO.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package net.sarasarasa.dataobject;import lombok.Data;import javax.persistence.*;import java.io.Serializable;import java.util.Date;import java.util.List;/** * @author AyagiKei * @url https://github.com/Ayagikei **/@Data@Entity@Table(name = "shiro_role")public class RoleDO implements Serializable &#123; private static final long serialVersionUID = 2532670665590869938L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = "role_id") private Integer roleId; private String role; @ManyToMany @JoinTable(name = "shiro_user_role", joinColumns = &#123;@JoinColumn(name = "role_id")&#125;, inverseJoinColumns = &#123;@JoinColumn(name = "user_id")&#125;) private List&lt;UserDO&gt; userList; @ManyToMany @JoinTable(name = "shiro_role_permission", joinColumns = &#123;@JoinColumn(name = "role_id")&#125;, inverseJoinColumns = &#123;@JoinColumn(name = "permission_id")&#125;) private List&lt;PermissionDO&gt; permissionList; // 创建时间 @Column(name = "create_time") private Date createTime; private String remark; @Override public String toString() &#123; return role; &#125;&#125; UserDO.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package net.sarasarasa.dataobject;import lombok.Data;import javax.persistence.*;import java.io.Serializable;import java.util.Date;import java.util.List;/** * @author AyagiKei * @url https://github.com/Ayagikei **/@Data@Entity@Table(name = "shiro_user")public class UserDO implements Serializable &#123; private static final long serialVersionUID = -2319943079325710028L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = "user_id") private Integer userId; @Column(name = "username", nullable = false, unique = true) private String username; private String nickname; private String password; private String salt; // 密码加盐 @ManyToMany(fetch = FetchType.EAGER) @JoinTable(name = "shiro_user_role", joinColumns = &#123;@JoinColumn(name = "user_id")&#125;, inverseJoinColumns = &#123;@JoinColumn(name = "role_id")&#125;) private List&lt;RoleDO&gt; roleList; // 创建时间 @Column(name = "create_time") private Date createTime; private String remark; @Override public String toString() &#123; return "User[id = " + userId + ", username = " + username + ", password = " + password + ", salt = " + salt + "]"; &#125;&#125; 注意Username是要保证唯一性的。 初始化数据库数据123456789101112131415161718INSERT INTO shiro_user (id, password, salt, username) VALUES (1, "dev", "salt", "admin");INSERT INTO shiro_role (id, role) VALUES (1, "admin"), (2, "normal");INSERT INTO shiro_permission (id, permission) VALUES (1, "user info"), (2, "user add"), (3, "user del");INSERT INTO shiro_user_role (user_id, role_id) VALUES (1, 1);INSERT INTO shiro_role_permission (permission_id, role_id) VALUES (1, 1), (2, 1); 这里的数据直接来自参考的文章（偷懒。 JPA查询接口123public interface UserRepository extends JpaRepository&lt;User, Integer&gt; &#123; User findByUsername(String username);&#125; 对于Shiro暂时只需要这个接口。 Shiro 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package net.sarasarasa.config;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.LinkedHashMap;import java.util.Map;/** * @author AyagiKei * @url https://github.com/Ayagikei * 对Shiro的配置 **/@Configurationpublic class ShiroConfiguration &#123; /** * 开启对注解 `@RequirePermission` 的支持 * 在按参考的文章写完配置之后，依然不能使用RequirePermission注解， * 在加上这个方法之后才ok。 */ @Bean public static DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() &#123; DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator(); defaultAdvisorAutoProxyCreator.setUsePrefix(true); return defaultAdvisorAutoProxyCreator; &#125; @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123; AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; &#125; /** * 自己实现的 Realm，Shiro 的认证最终都交给 Realm 进行执行了。我们需要自己实现一个 Realm，继承自 AuthrozingRealm */ @Bean public MyShiroRealm myShiroRealm() &#123; return new MyShiroRealm(); &#125; @Bean public DefaultWebSecurityManager securityManager() &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(myShiroRealm()); return securityManager; &#125; @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager); Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); // 指定访问所需要的权限perms或者roles // url可以用**或者*表示不同程度的通配符匹配 // 这里重叠匹配的url好像跟调用顺序有关 filterChainDefinitionMap.put("/page/manage/**", "perms[manage]"); filterChainDefinitionMap.put("/page/manage/**", "roles[manager]"); filterChainDefinitionMap.put("/static/**", "anon"); filterChainDefinitionMap.put("/login", "anon"); filterChainDefinitionMap.put("/**", "authc"); // authc 表示需要验证身份才能访问，anon 表示不需要 filterChainDefinitionMap.put("/toUser", "user"); // user与authc比较相似， // 表示用户不一定需要已经通过认证,只需要曾经被Shiro记住过登录状态(rememberMe)就可以正常访问。 // 设置登陆页面，在没有登陆之前访问需要验证的页面会跳转到这里 shiroFilterFactoryBean.setLoginUrl("/login"); // 设置未授权页面，在登陆后访问权限不够的页面会跳转到这里（不设置默认返回401页面） shiroFilterFactoryBean.setUnauthorizedUrl("/unauthorized"); // 如果不设置，默认 Shiro 会寻找 classpath:/template/login.jsp 文件 shiroFilterFactoryBean.setSuccessUrl("/index"); // 成功登陆后跳转 // 配置注销页面，访问该链接会自动实现注销（登出）功能 filterChainDefinitionMap.put("/logout", "logout"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; &#125;&#125; Shiro 认证和授权Shiro 的认证和授权操作都是交给 Realm 类实现的，我们要自定义一个 Realm 实现获取数据（用户对应的角色、权限，还有密码等）的具体逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package net.sarasarasa.config;import lombok.extern.slf4j.Slf4j;import net.sarasarasa.dao.UserRepository;import net.sarasarasa.dataobject.PermissionDO;import net.sarasarasa.dataobject.RoleDO;import net.sarasarasa.dataobject.UserDO;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authc.credential.CredentialsMatcher;import org.apache.shiro.authc.credential.HashedCredentialsMatcher;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.util.ByteSource;import org.springframework.beans.factory.annotation.Autowired;/** * @author AyagiKei * @url https://github.com/Ayagikei **/@Slf4jpublic class MyShiroRealm extends AuthorizingRealm &#123; @Autowired private UserRepository userRepository; /** * 负责授权，获取用户所拥有的所有权限 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; log.info("权限配置：MyShiroRealm.doGetAuthorizationInfo"); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); UserDO user = (UserDO) principalCollection.getPrimaryPrincipal(); log.info("为用户 " + user.getUsername() + " 进行权限配置"); for (RoleDO role : user.getRoleList()) &#123; authorizationInfo.addRole(role.getRole()); for (PermissionDO permission : role.getPermissionList()) &#123; authorizationInfo.addStringPermission(permission.getPermission()); &#125; &#125; return authorizationInfo; &#125; /** * 负责身份认证，即登陆的时候验证密码 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; log.info("开始身份认证"); String username = (String) authenticationToken.getPrincipal(); log.info("输入得到的用户名：" + username); UserDO user = userRepository.findByUsername(username); // 从数据库中查找 UserDO if (user == null) &#123; return null; &#125; log.info("用户信息：\n" + user.toString()); SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo( user, user.getPassword(), // ByteSource.Util.bytes(user.getSalt()), // 对密码进行加盐验证 getName() ); return authenticationInfo; &#125;&#125; 没有进行加盐验证的Shiro配置就这样写好了，可以先进行简单测试。 Controller + 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package net.sarasarasa.controller;import lombok.extern.slf4j.Slf4j;import net.sarasarasa.dao.UserRepository;import net.sarasarasa.dataobject.UserDO;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.DisabledAccountException;import org.apache.shiro.authc.IncorrectCredentialsException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.subject.Subject;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.*;import java.util.HashMap;import java.util.Map;@Slf4j@Controllerpublic class LoginController &#123; @Autowired private UserRepository userRepository; @PostMapping("/login") public @ResponseBody Map&lt;String, Object&gt; login( @RequestParam(value = "username") String username, @RequestParam(value = "password") String password) &#123; log.info("用户登陆，使用username=" + username + " password=" + password); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); Subject user = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(username, password); map.put("success", false); try &#123; user.login(token); map.put("success", true); &#125; catch (UnknownAccountException | IncorrectCredentialsException e) &#123; map.put("msg", "账号不存在或密码错误！"); &#125; catch (DisabledAccountException e) &#123; map.put("msg", "账号未启用！"); &#125; catch (Throwable e) &#123; map.put("msg", "未知错误！"); &#125; return map; &#125;&#125; 这里就不放页面了，可以用Postman之类的简单测试下。 接下来讲讲开始加盐验证。 加盐验证首先先让我们的admin账号的密码加个密，Controller中加入： 12345678910111213/** * 临时使用对admin用户的密码进行加盐操作的方法 **/@RequestMapping("/en")@ResponseBodypublic String encrypt() &#123; UserDO user = userRepository.findByUsername("admin"); // 这里用的盐选择是时间+固定字符串然后MD5的结果 user.setSalt((new SimpleHash("MD5", userDO.getPassword(), ByteSource.Util.bytes(new Date().toString() + "Sara"), 1024)).toString()); user.setPassword((new SimpleHash("MD5", userDO.getPassword(), ByteSource.Util.bytes(userDO.getSalt()), 1024)).toString()); userRepository.save(user); return "";&#125; 然后访问一下“/en”。 注入加密方式方法1：重写 MyShiroRealm（自定义 Realm 类）的 setCredentialsMatcher 方法：1234567891011/** * 使用加盐验证 **/@Overridepublic void setCredentialsMatcher(CredentialsMatcher credentialsMatcher) &#123; // 重写 setCredentialsMatcher 方法为自定义的 Realm 设置 hash 验证方法 HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher(); hashedCredentialsMatcher.setHashAlgorithmName("MD5"); hashedCredentialsMatcher.setHashIterations(1024); super.setCredentialsMatcher(hashedCredentialsMatcher);&#125; 方法2：在 ShiroConfiguration 中注入：12345678910111213141516171819@Configurationpublic class ShiroConfiguration &#123;// ... @Bean public HashedCredentialsMatcher hashedCredentialsMatcher()&#123; HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher(); hashedCredentialsMatcher.setHashAlgorithmName("md5"); hashedCredentialsMatcher.setHashIterations(1024); return hashedCredentialsMatcher; &#125; @Bean public MyShiroRealm myShiroRealm() &#123; MyShiroRealm myShiroRealm = new MyShiroRealm(); myShiroRealm.setCredentialsMatcher(hashedCredentialsMatcher()); return myShiroRealm; &#125;&#125; 在MyShiroRealm的doGetAuthenticationInfo方法中传入盐12345678910111213141516171819202122...@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; log.info("开始身份认证"); String username = (String) authenticationToken.getPrincipal(); log.info("输入得到的用户名：" + username); UserDO user = userRepository.findByUsername(username); if (user == null) &#123; return null; &#125; log.info("用户信息：\n" + user.toString()); SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo( user, user.getPassword(), ByteSource.Util.bytes(user.getSalt()), // 其实就是加上这句 getName() ); return authenticationInfo;&#125;... 至此应该就实现了Shiro的完整配置了。 遇到过的一些问题LazyInitializationExceptionJPA + shiro好像可能会遇到这个懒加载的问题，这个异常出现在已经认证的用户访问一些需要特定权限的页面 。 我采用的解决方案是在application.yml中加入一句： 1spring.jpa.properties.hibernate.enable_lazy_load_no_trans = true 这个可能有些弊端，，可以参考下另外的解决方案：https://blog.csdn.net/zcs20082015/article/details/80751626 @RequiresPermissions不生效，并且不会跳转到指定的未验证页面其实上面的代码已经解决了不生效的问题，原本参考的文章里没有注入这个方法，加入之后就没问题了。 12345678@Beanpublic static DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() &#123; DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator(); defaultAdvisorAutoProxyCreator.setUsePrefix(true); return defaultAdvisorAutoProxyCreator;&#125; 注解的使用方法： 1@RequiresPermissions(value = "manage add update") 然后注解拦截的确实不会跳转到我们在Shiro配置里指定的页面，而是会抛出一个异常UnauthorizedException，我们可以在全局异常处理中接收这个异常然后重定向： 12345678910111213141516171819202122232425262728293031323334353637package net.sarasarasa.exception.handlerimport org.apache.shiro.authz.UnauthorizedExceptionimport org.slf4j.LoggerFactoryimport org.springframework.web.bind.annotation.ControllerAdviceimport org.springframework.web.bind.annotation.ExceptionHandlerimport org.springframework.web.bind.annotation.ResponseBodyimport org.springframework.web.servlet.ModelAndView/** * @author AyagiKei * @url https://github.com/Ayagikei * **/@ControllerAdviceclass GlobalExceptionHandler &#123; private val log = LoggerFactory.getLogger(this.javaClass) /** * 拦截未授权异常，重定向到"未授权"页面 */ @ExceptionHandler(value = UnauthorizedException::class) fun handleUserAuthorizeException(): String &#123; return "redirect:/unauthorized" &#125; @ExceptionHandler(value = Exception::class) @ResponseBody fun handleGlobalException(e: Exception): ModelAndView &#123; e.printStackTrace() log.error("系统异常：", e.toString()) val view = ModelAndView() return view &#125;&#125; 尝试混用 Kotlin 启动报错上面的全局异常用的就是Kotlin，发现少了一个maven依赖： 12345678910111213141516171819&lt;!-- kotlin --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-stdlib-jdk8&lt;/artifactId&gt; &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-test&lt;/artifactId&gt; &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 就是少了这个reflect的依赖，启动的时候会失败 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-reflect&lt;/artifactId&gt; &lt;version&gt;1.2.41&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>技术</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>后端</tag>
        <tag>SpringBoot2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#15 | 04/02 用Fragment改造设置页面]]></title>
    <url>%2Fpost%2F6f83efb3.html</url>
    <content type="text"><![CDATA[之前使用Fragment都是配合ViewPager或者配合TabLayout+ViewPager，基本没用过FragmentManager。 实际使用之后才发现，Fragment能实现到和Activity在使用上分辨不出的效果。 布局文件其实我们要实现的效果很简单，一个主Fragment显示各个设置的大类（比如显示设置、小部件设置等），点击之后切换到不同的Fragment显示，然后那些Fragment只能回退到主Fragment，主Fragment再回退就是结束Activity。 大概这样： Fragment的布局文件正常就好。 Activity要怎么样呢？我们的Activity本身是不需要任何内容的，只需要充当一个容器的作用就行： activity_setting.xml 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/fragment_container" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:background="@color/background_color" android:fitsSystemWindows="true" tools:context=".activities.SettingActivity"&gt;&lt;/LinearLayout&gt; 填充Fragment在Activity对Fragment进行操作是要，通过FragmentManager获得FragmentTransaction进行add/remove/replace等处理的。 具体如何对上述布局里的fragment_container填充Fragment呢？ 123456789101112override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_setting) // 这是为了防止重复添加 if (supportFragmentManager.findFragmentById(R.id.fragment_container) == null) &#123; val transaction = supportFragmentManager.beginTransaction() transaction.add(R.id.fragment_container, SettingMainFragment()) // 在对transaction进行各种操作之后，要用commit()方法提交修改 .commit() &#125;&#125; 那么如何替换Fragment呢？ 使用FragmentTransaction，只不过调用的方法是replace() 12345678override fun mainToSettingChildrenFragment(childrenFragment: Fragment) &#123; supportFragmentManager.beginTransaction() // 在我们这个例子中，只有Main Fragment会调用这个方法 .replace(R.id.fragment_container, childrenFragment) // 这里可以将当前的Fragment压入回退栈，等会返回使用 .addToBackStack("main") .commit()&#125; 在其他Fragment返回Main Fragment的方法： 123override fun popBackStack() &#123; supportFragmentManager.popBackStack()&#125; 接口回调实现Activity和Fragment通信这些方法是写在Activity中的，Fragment要怎么调用Activity的方法呢？ 这里可以使用到接口回调的方法。 定义一个BaseSettingFragment，并且在其中定义接口： 12345678abstract class BaseSettingFragment : Fragment() &#123; interface SettingActivityListener &#123; fun mainToSettingChildrenFragment(childrenFragment: Fragment) fun popBackStack() &#125; abstract fun initView(rootView:View)&#125; Activity要实现这个两个接口，然后在Fragment之中： 1234567891011private val settingActivityListener: SettingActivityListener? by lazy &#123; if (activity != null &amp;&amp; activity is SettingActivityListener) activity as SettingActivityListener else null&#125;// 然后你就能调用Activity之中这两个方法了：...settingActivityListener?.popBackStack()settingActivityListener?.mainToSettingChildrenFragment(SettingDisplayFragment())... 让Fragment伪装成ActivityToolbar和回退按钮因为我们的例子中Activity的布局文件是没有加上Toolbar的，所以我们要在Fragment之中实现Toolbar。 我们这里是把Toolbar当做独立控件使用，即Standalone Toolbar。 有个问题就是，这样子我们在Fragment是调用不了setDisplayHomeAsUpEnabled()方法显示出回退键的，那么该怎么办呢？ 查了一下Stackoverflow，发现加上一个神奇的参数就可以了： 1app:navigationIcon="?homeAsUpIndicator" Toolbar相关的布局内容： 1234567891011121314&lt;com.google.android.material.appbar.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/AppTheme.AppBarOverlay"&gt; &lt;androidx.appcompat.widget.Toolbar android:id="@+id/setting_toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" app:navigationIcon="?homeAsUpIndicator" app:popupTheme="@style/AppTheme.PopupOverlay" /&gt;&lt;/com.google.android.material.appbar.AppBarLayout&gt; 然后你就可以设置Title和按键监听： 12toolbar.setNavigationOnClickListener &#123; settingActivityListener?.popBackStack() &#125;toolbar.title = "桌面小部件设置" 这样的效果就和普通的Activity无异了。 当然，除了一点： 切换动画实际运行会发现Fragment的切换是默认不带动画的。 其中Fragment是有默认的切换动画的，只是没有开启。 调用FragmentTransaction的setTransition(int)方法就可以设置相应的动画效果。 参数可以传入TRANSIT_FRAGMENT_FADE、TRANSIT_FRAGMENT_OPEN、TRANSIT_FRAGMENT_CLOSE等，具体可以参考https://developer.android.com/reference/android/app/FragmentTransaction 自带的这几个效果并没有Activity默认的SLIDE_IN等，这时候就要用到自定义动画了。 调用FragmentTransaction的setCustomAnimations方法即可。 该方法有两种使用方法，一种是只传入ENTER和EXIT动画，另外一种是再这两种的基础上再加上入栈出栈的动画。 因为我们的例子中，回退是用出栈实现的，自然要实现第二种。 首先新建动画文件： slide_left_in.xml 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="300" android:fromXDelta="-100.0%p" android:toXDelta="0.0" /&gt;&lt;/set&gt; slide_left_out.xml 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="300" android:fromXDelta="0.0" android:toXDelta="-100.0%p" /&gt;&lt;/set&gt; slide_right_in.xml 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="300" android:fromXDelta="100.0%p" android:toXDelta="0.0" /&gt;&lt;/set&gt; slide_right_out.xml 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="300" android:fromXDelta="0.0" android:toXDelta="100.0%p" /&gt;&lt;/set&gt; 更改我们的mainToSettingChildrenFragment(childrenFragment: Fragment)方法的实现： 12345678override fun mainToSettingChildrenFragment(childrenFragment: Fragment) &#123; supportFragmentManager.beginTransaction() // 其实就是加上了这一句 .setCustomAnimations(R.anim.slide_right_in, R.anim.slide_left_out, R.anim.slide_left_in, R.anim.slide_right_out) .replace(R.id.fragment_container, childrenFragment) .addToBackStack("main") .commit()&#125; 还有一点要注意，setCustomAnimations方法要在add/remove/replace/addToBackStack等方法前调用，要不然动画效果不会生效。]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#14 | 03/21 几个小问题的解决]]></title>
    <url>%2Fpost%2Fb122a7c6.html</url>
    <content type="text"><![CDATA[ViewPager + Fragments 导致的选项菜单错乱解决原先的Toolbar实现在Fragment中获取Toolbar这个View，然后调用Activity的setSupportActionBar(toolbar)方法。 然后实现Option菜单的方法：在Fragment中设置setHasOptionsMenu(true)，然后重写fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater)方法。 出现的问题：似乎是因为ViewPager的缓存机制，导致切换Fragments切换的时候可能出现菜单错乱的情况。 解决：把Toolbar当做控件使用MainActivity.kt 12345678910111213fun initToolBar(toolbar: Toolbar) &#123; //setSupportActionBar(toolbar) 注释掉这条 currentToolbar = toolbar val toggle = ActionBarDrawerToggle( this, drawer_layout, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close) drawer_layout.addDrawerListener(toggle) nav_view.setNavigationItemSelectedListener(this)&#125;fun getCurrentToolbar(): Toolbar? &#123; return currentToolbar&#125; Fragment.kt 1234567891011121314151617private fun initToolbar(view: View) &#123; //设置toolbar mToolbar = view.findViewById(R.id.toolbar) (activity as MainActivity).initToolBar(mToolbar) // 填充菜单 mToolbar?.inflateMenu(R.menu.main) mToolbar?.setOnMenuItemClickListener &#123; item -&gt; when (item.itemId) &#123; R.id.action_sort -&gt; &#123; // do something true &#125; else -&gt; true &#125; &#125;&#125; 菜单同时显示图标和文字没有直接实现的方法，这里可以利用反射： 123456789101112if (mToolbar != null) &#123; val mMenu = mToolbar!!.menu if (mMenu.javaClass.simpleName.contentEquals("MenuBuilder")) &#123; try &#123; val method = mMenu.javaClass.getDeclaredMethod("setOptionalIconsVisible", java.lang.Boolean.TYPE) method.isAccessible = true method.invoke(mMenu, true) &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; &#125;&#125; 用代码动态调整MaxWidth123456789val tw = helper.getView(R.id.tv_nickname) as TextViewval cw = helper.getView(R.id.cl_history) as ConstraintLayoutval twDate = helper.getView(R.id.tv_btn) as TextViewcw.post &#123; val newMaxWidth = cw.width - DensityUtil.dp2px(72f) - twDate.width if (newMaxWidth &gt; 0) &#123; tw.maxWidth = newMaxWidth &#125;&#125; Android P 发送不了网络请求这是因为Android P默认禁用了HTTP请求，只支持HTTPS。 1. 在AndroidManifest.xml的Application标签加上： 1android:networkSecurityConfig="@xml/network_security_config" 2. 然后在res/xml文件夹里新建network_security_config.xml文件： 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true" /&gt;&lt;/network-security-config&gt; 全面屏简单适配在`AndroidManifest.xml的Application标签里声明一下支持的屏幕高宽比： 1&lt;meta-data android:name="android.max_aspect" android:value="2.4" /&gt;]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#13 | 03/21 迁移至AndroidX]]></title>
    <url>%2Fpost%2Fd848a650.html</url>
    <content type="text"><![CDATA[AndroidX是 Google 发布的对原来的支持库整理后的新一代支持库。并且原来的支持库的最后版本将停留在“28.0.0”，迁移是迟早的事情。 主要动机还是想要用一个框架，结果它只支持AndroidX，就这样决定开始迁移了。 利用Android Studio迁移需求：Android Studio版本3.2以上 操作：Refactor -&gt; Migrate to Androidx IDE会询问是否要备份一份当前的项目，并且会告知可能需要你手动解决一些项目Error。 继续操作，IDE会搜索所有的要改变的依赖路径，然后点击DO REFACTOR按钮吧。 解决问题马上Gradle Build就出现了第一个问题12Android resource compilation failed error: duplicate value for resource &apos;attr/visibility&apos; with config &apos;&apos;. and error: resource previously defined here. 检索可知，这是依赖库的一个Bug。 1androidx.constraintlayout:constraintlayout:2.0.0-alpha3 解决方法：暂时将alpha3降级到alpha2，等待下一个版本解决。 参考链接：https://stackoverflow.com/questions/53908854/android-resource-compilation-failed-error-duplicate-value-for-resource-attr-vi Kotlin的View依赖失效解决方法：重新导一下View的依赖就好。 第三方框架的错误第三方框架有的可能还依赖于原始的支持库，这时IDE会报错。 这里有2个解决方案： 1. 更新框架一般坚持维护的大型框架都有提供 AndroidX 版本，更新一下即可。 2. 修改 gradle.properties12android.useAndroidX=trueandroid.enableJetifier=true android.useAndroidX=true 表示当前项目启用 AndroidX android.enableJetifier=true表示启用 Jetifier。而Jetifier会在构建项目的时候，将你的第三方依赖里面的旧支持库依赖自动转换为AndroidX支持库。]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VectorDrawable(xml)转换回SVG]]></title>
    <url>%2Fpost%2F396831a4.html</url>
    <content type="text"><![CDATA[Android 用的矢量图是 VectorDrawable（xml格式）。 如果我们想对已经转换成 VectorDrawable 的矢量图进行修改的话， 最好先转换回 SVG 格式再使用 inkscape 之类的矢量图图形编辑工具进行修改。 步骤 将头部的： 12&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;vector xmlns:android="http://schemas.android.com/apk/res/android" 替换成 1&lt;svg xmlns="http://www.w3.org/2000/svg" 闭标签也做相应修改。 将android:width替换成width 将android:height替换成height 将android:pathData替换成d。 将android:fillColor替换成fill。 如果没有android:fillcolor的话，要加上fill=&quot;#ffffff&quot; 将android:viewportHeight=&quot;24&quot; android:viewportWidth=&quot;24&quot;替换成viewBox=&quot;0 0 24 24&quot;的形式。 例子Vector Drawable 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;vector xmlns:android="http://schemas.android.com/apk/res/android" android:width="24dp" android:height="24dp" android:viewportHeight="24" android:viewportWidth="24"&gt; &lt;path android:fillColor="#ffffff" android:pathData="M12,3L2,12h3v8h2.5v-0.8c0-1.5,3-2.2,4.5-2.2s4.5,0.8,4.5,2.2V20H19v-8h3L12,3zM12,15.2c1.2,0-2.2-1-2.2-2.2 s1-2.2,2.2-2.2s2.2,1,2.2,2.2S13.2,15.2,12,15.2z" /&gt; &lt;path android:pathData="M0,0h24v24H0V0z" /&gt;&lt;/vector&gt; SVG 12345678910&lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" &gt; &lt;path fill="#ffffff" d="M12,3L2,12h3v8h2.5v-0.8c0-1.5,3-2.2,4.5-2.2s4.5,0.8,4.5,2.2V20H19v8h3L12,3zM12,15.2c1.2,0-2.2-1-2.2-2.2 s1-2.2,2.2-2.2s2.2,1,2.2,2.2S13.2,15.2,12,15.2z" /&gt; &lt;path d="M0,0h24v24H0V0z" fill="none"/&gt;&lt;/svg&gt; 参考https://stackoverflow.com/questions/44948396/convert-vectordrawable-to-svg]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#12 | 01/17 图表]]></title>
    <url>%2Fpost%2F3974e9e2.html</url>
    <content type="text"><![CDATA[本文讲讲怎么用 MPAndroidChart 框架实现折线图、柱形图、饼图，并且进行样式设置，达到和宣传图差不多的效果。 一开始看到 MPAndroidChart 的各种图表介绍图感觉很好看，但是直接New一个相应图表，仅仅填充数据的话，样式稍微有些丑。经过一番阅览文档才把样式调整得好看些。所以就写了这篇文章记录下。 APP 里实现的最终效果： 引入框架首先是引入框架： https://github.com/PhilJay/MPAndroidChart Gradle设置一下： 1234567repositories &#123; maven &#123; url 'https://jitpack.io' &#125;&#125;dependencies &#123; implementation 'com.github.PhilJay:MPAndroidChart:v3.1.0-alpha'&#125; LineChart 折线图显示数据首先，先让我们的图标正确显示数据吧~ XML 布局文件内加入： 1234&lt;com.github.mikephil.charting.charts.LineChart android:id="@+id/line_chart" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; Entry，Entry 可以理解为一个点，赋值 x 和 y 数值。 123456val lineEntries = ArrayList&lt;Entry&gt;()for ((i, e) in countList.withIndex()) &#123; val entry = Entry(i.toFloat(), e.toFloat()) lineEntries.add(entry)&#125; LineDataSet，可以理解为一条线。 1val lineDataSet = LineDataSet(lineEntries, "") LineData，可以理解为多条线的集合。 12345val lineData = LineData(lineDataSet)view.line_chart.data = lineData// 填充数据后要重绘图表view.line_chart.invalidate() 然后你会得到： 嗯，默认样式有点丑。接下来就是修改样式了。 设置样式 设置LineDataSet的样式。 123456789101112131415lineDataSet.apply&#123; // 不在坐标点上显示 y 数值 setDrawValues(false) /* 改为曲线显示模式，一共有四种显示模式： LINEAR,STEPPED,CUBIC_BEZIER,HORIZONTAL_BEZIER */ mode = LineDataSet.Mode.HORIZONTAL_BEZIER // 改变线条颜色 color = resources.getColor(R.color.blue) // 不显示相应坐标点的小圆圈 setDrawCircles(false) setDrawCircleHole(false) // 设置线的宽度 lineWidth = 1.5f&#125; 设置 X 轴的样式。 12345678910111213141516171819val xAxis = view.chart.xAxis// 这里的listStringDatePastDays方法的功能是获取近7天的日期字符串数组val stringDateList = DateUtil.listStringDatePastDays(7)xAxis.apply&#123; // 取消网格线显示 setDrawGridLines(false) // 位置改到图表下方 position = XAxis.XAxisPosition.BOTTOM // x轴起始改为0 axisMinimum = 0f // x轴的最小单位设置为1f granularity = 1f // 改变x轴的显示内容， // 然后设置valueFormatter将x轴的数值对应上日期，然后实际上就会显示日期了。 valueFormatter = IAxisValueFormatter &#123; value, axis -&gt; stringDateList[value.toInt()] &#125;&#125; 设置左侧 Y 轴的样式。（同理 x 轴） 1234val yAxis = view.line_chart_exp.axisLeftyAxis.granularity = 1f// 如果你的y轴数值是正数的话，建议最小值为0，因为默认的话会略小于0。yAxis.axisMinimum = 0f 图表的样式设置。 1234567891011121314151617view.chart.apply&#123; // 禁用图例 legend.isEnabled = false // 禁用触摸响应 setTouchEnabled(false) // 禁用右侧的y轴 axisRight.isEnabled = false // 取消右下角的Description Label description.isEnabled = false // 取消背景的网格绘制 setDrawGridBackground(false) // 没有数据的时候显示的文本内容 setNoDataText("暂时没有相应数据") // 设置动画效果 animateY(1000, Easing.Linear) animateX(1000, Easing.Linear)&#125; 然后就能得到这样的效果： BarChart 柱形图柱形图与折线图类似，只是： Entry 变成了 BarEntry LineDataSet 变成了 BarDataSet LineData 变成了 BarData LineChart 变成了 BarChart 样式设置也差不多，就直接贴代码了： 123456789101112131415161718192021222324252627282930313233343536373839private fun initStepBarChart(view: View) &#123; val barEntries = ArrayList&lt;BarEntry&gt;() val stepList = stepService.listFinishTaskCountPastDays(7) for ((i, e) in stepList.withIndex()) &#123; val entry = BarEntry(i.toFloat(), e.toFloat()) barEntries.add(entry) &#125; val barDataSet = BarDataSet(barEntries, "") context?.let &#123; barDataSet.color = (ContextCompat.getColor(it, R.color.color_bar_chart)) &#125; barDataSet.setDrawValues(true) val barData = BarData(barDataSet) val xAxisOfBarData = view.bar_chart_step.xAxis val stringDateList = DateUtil.listStringDatePastDays(7) xAxisOfBarData.apply &#123; valueFormatter = IAxisValueFormatter &#123; value, axis -&gt; stringDateList[value.toInt()] &#125; position = XAxis.XAxisPosition.BOTTOM //xAxisOfBarData.setDrawAxisLine(false) setDrawGridLines(false) &#125; val yAxisOfBarData = view.bar_chart_step.axisLeft yAxisOfBarData.apply &#123; axisMinimum = 0f setDrawGridLines(false) &#125; view.bar_chart_step.apply &#123; legend.isEnabled = false data = barData description.isEnabled = false setDrawGridBackground(false) axisRight.isEnabled = false animateY(1000, Easing.Linear) animateX(1000, Easing.Linear) setNoDataText("暂时没有相应数据") invalidate() &#125;&#125; PieChart 饼图填充数据依旧类似： Entry 变成了 PieEntry LineDataSet 变成了 PieDataSet LineData 变成了 PieData LineChart 变成了 PieChart 完整代码： 12345678val pieEntries = ArrayList&lt;PieEntry&gt;()pieEntries.add(PieEntry(0.3, "Pie1"))pieEntries.add(PieEntry(0.5, "Pie2"))pieEntries.add(PieEntry(0.2, "Pie3"))val pieDataSet = PieDataSet(pieEntries, "")val pieData = PieData(pieDataSet)view.pie_chart_exp.data = pieDataview.pie_chart_exp.invalidate() 稍微注意一点的地方是，PieEntry没有x、y值，只有一个value占比数值。 所有PieEntry的Value总和应该为1，要不然可能显示不正常。 然后你会得到一块效果很丑的饼： 可以看到所有每一块的颜色都是相同的，图例也只显示了一个，并且所有饼块都紧邻在了一起，右下角的描述也需要去掉，冰块上方的数字应该改成百分比显示。 设置样式 首先是设置颜色。 123456// pieColors的颜色会与pieEntries一一对应val pieColors = ArrayList&lt;Int&gt;()pieColors.add(ContextCompat.getColor(context,R.color.red))pieColors.add(ContextCompat.getColor(context,R.color.green))pieColors.add(ContextCompat.getColor(context,R.color.blue))pieDataSet.colors = pieColors PieDataSet设置饼块间隔、数值字体大小。 12pieDataSet.sliceSpace = 3.0fpieDataSet.valueTextSize = 9.0f PieData设置数值以百分比显示和字体颜色。 123// 设置ValueFormatter让数值变成百分号（%）形式显示，但是数值还是原来的0.xpieData.setValueFormatter(PercentFormatter())pieData.setValueTextColor(ContextCompat.getColor(it, R.color.white)) PieChart的样式设置。 1234567891011121314view.pie_chart_exp.apply&#123; // 设置以百分比显示，这里是指将原来的0.x乘100，并不会加上“%”符号 setUsePercentValues(true) // 设置Label的字体大小（比如上方的Pie1） setEntryLabelTextSize(10.0f) // 设置中间的文本显示 centerText = "经验分布" // 去掉右下角的Description description.isEnabled = false setNoDataText("暂时没有相应数据") // 开启动画效果 animateY(1000, Easing.Linear) animateX(1000, Easing.Linear)&#125; 至此，饼图已经变得挺好看了： 当然，你还能进行更多的样式调整，可以参考官方Github Wiki和API文档的介绍。 官方文档WIKI使用教程 详细API文档]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「工行星座卡校园版」从下卡到海外在线支付]]></title>
    <url>%2Fpost%2F325f3e25.html</url>
    <content type="text"><![CDATA[为什么需要一张信用卡信用卡对于没有稳定收入的大学生可能显得有些遥远，但对我个人而言感觉很多地方，如果有一张支持visa的信用卡可以方便很多： 美亚、日亚 Digital Ocean Google Play以及开发者认证 甚至一些云服务的学生优惠领取都需要信用卡 还有很多信用卡独有的优惠活动。 恰好学校用的银行卡是工行的，就在工行里找可以申办的信用卡，就看中了工行的这款星座卡校园版。 优与缺优点 双卡多币种（银联+Visa） 颜值高 校园版，大学生如实填写信息就能下卡 免年费 缺点 0额度（除非你在白名单高校并且家长签写担保书） 易掉漆 多币种可能占征信多个账户（实际影响可以参考：https://www.zhihu.com/question/67828005） 办卡流程1. 申办新卡我是在中国工商银行APP里申办的新卡，网页应该可以。 打开APP→信用卡→申请办卡→星座卡→立即申请→填写信息。 基本上如实填写即可，年薪可填生活费/奖学金等。（填写界面限制要大于0） 单位地址可填学校办公室地址，单位电话可填办公室电话（ 住址可填学生宿舍。 2. 等待发卡几个工作日会告诉你审批结果，然后用邮政邮寄到你的住址。 拿到卡片就可以去启用卡片了。 注意是分两个包裹分别邮寄银联卡和VISA卡。 第一次启用工行信用卡的话，好像必须去网点启用。 如果不是第一次，可以尝试在APP→信用卡→卡片启用内启用。 图为收到的卡片，两张卡星座居然不一样（ 3. 网点启用卡片带着身份证和两张信用卡去网点，告诉工作人员你要启用信用卡，就会被带到智能柜员机那里按照提示启用信用卡。启动之后最好同时开启电子银行（网银）。也可以领取U盾或者电子密码器。 ##4. 电子银行设置 打开APP→我的账户，查看两张卡是不是已经添加到了手机银行里，并且写着“柜面注册”而不是“自助注册”。 柜面注册的卡片才在网银里有更高的权限：比如卡间转账、对外支付等。 如果是”自助注册”的话，先移除卡片，然后去到银行网点，对这张卡重新激活电子银行。（也是在智能柜员机弄就好了） 返回APP首页→信用卡→划到VISA卡片→卡片设置→消费设置。 然后开通境外实时购汇和外卡组织验证服务，就可以开启你的海淘之旅了~ 海外在线支付步骤1. 转钱到信用卡因为是0额度卡，如果你没有外币余额的话，绑定海外在线支付时候的验证会划扣失败。 所以，我们要先让这张卡有你要的外币余额。 可以先支付宝绑定银联信用卡，然后还款到信用卡。（这里还款对于0额度信用卡可以说是相当于提现了）。 比如这里还款到银联信用卡70元人民币。（略大于10美元） 2. 人民币购汇外币然后打开工行APP→直接在搜索栏搜索“结售汇”。 选择你要的外币币种，选择交易类型为人民币购汇。 下一步，转入账号改成你的VISA卡卡号，支付账号可以是银联卡卡号。 钞汇标志应该强制为钞，购汇金额填写10（美元）。 然后填写购汇用途。 成功后，你的VISA信用卡会收到10美元余额。 3. 海外支付网站绑卡消费一般绑卡需要的必须信息是卡号、有效期限、办卡姓名（大写拼音）、安全码（CVV，持卡人签名那里的3位数字） 同时绑卡会划扣一笔小费用来测试VISA卡信息是不是有效，这笔费用一般都会等会就还给你。即，如果你绑的是日本网站，那么上一步你就应该购汇日元而不是美元了。 完大概就这样了~ 暂时还不清楚这张校园卡能不能提额，不过也可以曲线提额（申请另外一张工行信用卡，然后调整额度到该卡）。]]></content>
      <categories>
        <category>生活</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>信用卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 年终总结]]></title>
    <url>%2Fpost%2F1f18a9aa.html</url>
    <content type="text"><![CDATA[第一次写年终总结，也迟到了好几天。 今年真的经历了很多。 一整年没有写日记，也AFK了一整年的DOTA2（年末又玩回来了）。 也不知道要怎么写，就随便写写吧~ 写作今年，我的知乎专栏只发表了两篇文章： 不下载相应游戏也能完成「Steam涤尘送春活动」任务 查看你 Steam 账号的官方相关数据：总剁手金额、参与特卖数、探索队列历史等。 可以说，几乎等于没写。 倒是17年写的传送门的那篇文章进了知乎的编辑推荐： 5月份的时候，看到了游研社的二周年征文比赛，动了把一直酝酿的一篇文章写出来的心。 写文章的时候真的是困难重重，遣词造句更是难（ 不停地使用重复的连接词（ 可能是因为这种类型的长文写得少吧（ 投稿后，着急地各种刷着游研社的微博和公众号，突然有一天在公众号看到文章入选，开心得不行。 保底也拿到了300元~ https://mp.weixin.qq.com/s/psuJ7EpAHa5lf7aWCFbuDg 最后也止步300元，还是很满足的。 还被拉进了一个作者群。 这篇文章后续还没发到专栏和这个博客里，有时间完善一下再发吧~ 另外，圣诞节突然收到了知乎的一个消息，被莫名加入了知乎新用户的关注推荐列表。 然后关注人数疯长了近300人。 接着就是4月份的时候，看到了 hexo 搭建博客的文章，就搭起了这个博客。 刚搭好博客的时候倒是热情满满，后续都没怎么更新了（特别是年末。 不过也积累了30篇文章的量，还行吧。 大创原本今年还有个计划是搞搞大创项目的，题材稍微有点烂：大学生租赁平台。 我毫无项目经验地居然想单独一个人负责安卓端（ 拉着拉着人发现团队也略显臃肿，进行了投票调查和提案书编写，然后毫无意外地凉了。 开发 今年Github的贡献.jpg 人升LifeUp今年最大的成果估计就是《人升LifeUp》了。 几年前就尝试找类似的游戏化TODO应用，最后找到了一个LifeRPG，但是用起来不是顺手。 后来又看到了一个相关的知乎问题，就产生了自己开发一款这样的应用的念头。 但是想法和实际开发出的东西果然还是有不少差距的（ 这是一开始的思维导图，已经砍掉了人物角色的展示、职业之类的设定。 然后思维导图里面的技能也没实现（ Kotlin的文档都没能看下去，就直接用Kotlin进行了开发^_^，结果还行。 不过，最后实现的效果和取得的成就我还是很满意的，还要持续更新让APP更接近策划时候的样子~ 在制作这款APP之前，我也就写了个记录书籍的demo。可以说没什么安卓的开发经验orz。 在这个项目中接触了安卓的网络请求、图片加载、TOKEN处理、Fragment、桌面小部件、适配等开发等诸多知识，可谓受益良多。 参加校内的应用开发比赛也斩获了一个一等奖（1k）和一个二等奖（0.8k）。 上架了酷安平台，短短一个月收到了1k+的关注，9k+的下载量，有点被吓到了（ 一个月内接受了很多建议，也忽略了一些暂时不好实现的建议，更新了十几个版本。 途中有些版本更新重复制造了bug，实属开发经验不足。之后的更新发布需要更谨慎才行。 XX管理系统同学收到老师委托接下的一个项目，又分了一部分功能让我实现，拿到了1k。 稍微看了下慕课网上的Spring Boot入门视频就加入了开发（ 项目除了某个处理模块外，就是一个很标准的企业用的后台管理系统，可以查询各种类型订单，显示数据。然后还分为了普通用户和管理员，管理员可以直接查数据库表，还有表的Excel导出功能（Easypoi）等。 通过这个项目，我也快速了解了Spring Boot的实际项目的开发流程，MVC架构的基本知识，还有Ajax、LayUI之类的前端知识，虽然代码写得有些烂（ 比赛今年参加了校内的三个比赛，其中两个应用开发比赛，拿了人升LifeUp去参赛分别拿了一等和二等。 还有一场抱着去划水的心态去参加的信安CTF比赛，又运气很好地控制了一台其他组的电脑，拿下了三等（0.3k）。 娱乐游戏DOTA2 重拾了弃坑一年的DOTA2。自赛季制度出了之后没打过天梯，这次出了段位：万古1。 然后还一波连胜上了万古2。 不过这游戏还是过于竞技化了，无论输赢都可能影响到心情（ Kancolle 终于在年末12月31号晚上11点斩获了入坑以来的首个甲章~ 书籍今年好像就看了一本《眠》，还没看懂（ 下一年要加强下书籍的阅读量。 番剧番 齐木楠雄的灾难 第二季/完结篇 设定自洽的超能力搞笑番 七大罪 第二季 热血番，但本季感觉发挥一般 紫罗兰永恒花园 感情描写细腻的单元剧，作画无解棒，打斗剧情略差（ 龙王的工作 DARLING in the FRANXX 高开低走，血崩剧情 刻刻 比宇宙更远的地方 个人年度最佳番，追寻梦想 进击的巨人 第三季 超能力女儿 命运石之门0 作画不稳定+节奏怪+好剧情 刀剑神域外传GGO 工作细胞 杀戮天使 刀剑神域 第三季 SSSS.GRIDMAN 青春野狼不做兔女郎学姐的梦 剧 疑犯追踪 权利的游戏 1-7 毒枭 黑镜 第四季 行尸走肉 西部世界 第二季 2019年目标 起码阅读完12本书 继续完善《人升LifeUp》到自己满足的水平 找到一份满意的实习 48篇博文（大概一个星期一篇的程度） 达到对自己满意的程度]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升Lifeup 常见问题]]></title>
    <url>%2Fpost%2F157a032e.html</url>
    <content type="text"><![CDATA[关于版本目前，华为应用市场上的版本是被恶意篡改，插入广告，修改权限申请（甚至申请了录音权限）的版本。 该版本甚至不能打开登录界面、设置界面，尝试更新也会提示应用签名不正确。 如果你是从华为应用市场下载的，请尽快卸载。 目前，我们官方上架并且维护更新的应用市场有：酷安、魅族、小米、Google Play。 并且在这些应用市场上架的都是相同的包名，完全可以跨市场升级~ Google Play上架的是定为$0.99买断制的版本，暂时功能与其他版本并没有什么区别。如果你想支持我们的持续发展，可以考虑在Google Play上购买支持我们~ 捐赠过的用户可以向我们发送邮件获取Google Play的兑换码。 功能介绍建立事项通过期限时间和重复频次的配合，你能轻松地设置出“星期一”到“星期日”的每周事项。只要设置重复频次为“每周”，然后期限时间设置为“周末”即可~。相应的开始时间会自动计算得出。 通过开始时间、期限时间和重复频次的配合，你能轻松地设置出清空很复杂的待办事项。如每天的23：00到第二天的2：00的事项。只需要设置开始时间为具体的“当天23：00”，期限时间为具体的“第二天2：00”，重复频次为“每日”即可。 待补充 稍后阅读《人升》可以接受其他应用分享过来的信息，用以快速建立「稍后阅读」事项。并且默认会勾选“学识”属性。 支持大部分提供分享功能的应用：如“微博”、“知乎”、“浏览器”、“Twitter”等。 商店系统 待补充 社区 待补充 已知问题 目前Smartisan OS出现了裁剪图片崩溃的问题，经查日志发现是”缺少图片读取权限“。 但是该图片路径理论上应该是无需额外申请读写权限的，应该是OS本身的问题。待优化。 更新计划2019/7/13：因为目前在实习，稍微将原本大概7-14天一更的频次调整到14-21天一更。 下个版本预计发布日期：待定 预计更新内容： 金币清零 金币获取量统计 可能更新内容： 自定义排序 团队编辑优化 Q&amp;AQ：可以离线使用吗？ A：完全支持离线使用，只要你不需要用到社区方面的功能。 Q：社区团队是什么？ A：现在的社区其实是一个事项的发布和领取的地方，并且还支持了发表动态等功能。 Q：有广告或者内置收费吗？ A：没有任何广告和收费项目。 目前应用在 Google Play作为付费应用上架（0.99美元），功能暂时与国内各市场上架的版本一致。 Q：已经创建的事项可以编辑吗？ A：长按事项会弹出选项，可以进行编辑、删除、放弃、置顶等功能。 Q：已经完成的事项可以撤销吗？ A：今天以内完成的事项都可以在历史页面撤销。 Q：事项消失？ A：在老版本中，逾期的事项会自动中断，需要在历史页面中继续事项。新版新增了一个“自动重做逾期事项”的选项，默认开启，应该不会再出现这种情况了。 Q：没能收到事项的提醒？ A：现在的提醒用的是Android原生的闹钟机制，在国产定制系统里，这个闹钟机制需要应用后台运行才能正常运作。所以，最好不要依赖于当前版本的提醒功能。 Q：如何提建议或者提交BUG？ A：建议和提交BUG都可以在酷安评论区或者是私发邮件。如果是崩溃BUG的话，尽量麻烦发下崩溃报告，这对修复BUG有很大帮助。 更新日志1.66.1（2019/9/27） 【优化】将“紧迫程度”的文案变更为“重要程度” 【修复】修复“告示板”页面长按弹出菜单时，页面自动滚动的问题。 【修复】修复新建团队的时候，开始时间和结束时间设置无效的问题。 【修复】修复“默认不发表团队动态”初次设置不生效的问题。 【修复】修复查询已加入团队列表、关注列表、粉丝列表的一些问题。 1.66.0 （2019/9/25） 【功能】团队现在支持设置金币（范围限制0-99） 【功能】本地和团队现在支持设置随机金币 【功能】商店增加设置：自动使用购买的物品、贷款金额设置 【优化】属性升级增加提示，部分图标和颜色优化，事项卡片间隙改小 【优化】将正倒序选项移入“排序”选项里，并且增加现在使用的排序方式提示 【优化】优化团队事项的获取逻辑，增加获取时的提示，以及获取后自动刷新列表 【优化】标题栏增加自动收缩，增大可视面积 【优化】优化页面的加载逻辑，加快加载速度 【修复】修复可完成时间的错误显示 【修复】修复新增事项里的选择清单的“默认清单”名称显示不正确的问题 1.65.1 （2019/9/13） 【优化】桌面小部件增加显示“多次”事项的每日完成次数 【修复】Kotlin升级导致的一个严重崩溃问题 【修复】告示板列表刷新的一个崩溃问题 1.65.0 （2019/9/10） 【功能】稍后阅读：通过其他应用的分享功能（如知乎、微博、浏览器等）快速建立“稍后阅读事项”。 同时，事项备注中的链接现在支持点击调起浏览器。 【功能】自定义经验值惩罚倍数，可设置 0 - 5.0 倍。 【功能】商店、仓库的排序系统。（因为遇到了一些问题，仓库暂不支持拼音排序） 【功能】现在可以点击选择紧迫程度和困难程度了。 【功能】事项详情页面加上该事项完成总次数。 【功能】“多次”事项添加每天完成次数显示。 【优化】取消了状态页面的波浪动画和相应选项，该动画即便不播放也会消耗大量性能。 【优化】完成、放弃、删除事项后，自动取消该次事项的提醒。 【优化】优化社区搜索不到相应团队时的显示。 【优化】社区页面的新增按钮也添加自动隐藏功能，另外页面切换时会重新显示该按钮。 【优化】当选择的属性少于3个的时候，任务卡片不合理的间距修复。 【优化】优化了一些图标显示。 【修复】修复“事项详情”页面、“我的”页面不会及时刷新的问题。（修改团队信息现在还有这个问题，下个版本修复） 【修复】修复部分Android版本应用内语言修改不生效的问题。 【修复】修复了一两个可能的崩溃问题。 1.64.3 （2019/8/30） 修复完成/放弃/删除事项后，立刻进行变更清单/排序等操作引起的崩溃问题。 优化社区的页面加载逻辑。 1.64.2 （2019/8/29） 修复两个比较严重的崩溃问题 修复逾期事项的逾期时间显示问题，应该为期限时间 修复逾期事项设为「已经完成」不会增加金币的问题 修复新增事项里，选择清单的时，不能正确显示更改后的名字问题 1.64.1 （2019/8/28） 增加编辑商品功能，修复商品描述不生效的问题。 增加删除仓库记录功能，修复仓库记录时间不显示日期的问题 商店和统计对调了入口 商店页面滑动时自动隐藏“新增”按钮，增加点击tab回到最顶功能 优化计步统计 修复已建立事项的提醒时间/期限时间不能置空保存的问题 1.64.0 （2019/8/23） 全新的金币&amp;商店&amp;仓库激励体系：管理个人商店，上架商品（自己想要的奖励），设置价格（奖励获取的代价） 完成事项获得金币奖励，前往商店购买商品（获取奖励），然后在仓库中使用你的商品吧~ 新增放弃事项时的经验值损失提示 修复团队搜索、计步统计问题 统计页面的统计范围从7天调整为30天 一些布局优化，修复一些罕见崩溃。 注：金币现在仅本地事项支持，团队事项暂时不支持。后续会继续完善金币功能。 1.63.0（2019/8/11） 增加系统日历提醒机制（可在事项设置中更换） 增加清空经验值的功能 增加删除已发表的动态功能（在个人主页长按动态） 优化一些界面显示 1.62.3（2019/8/6） 采用新的崩溃反馈方式。 修复社区页面重复加载的问题。 修复一个获取经验值时的崩溃问题。 1.62.2 设置里增加自动检测更新功能。 修复[用户]页面的点赞操作失败的问题。 1.62.1 修复完成事项时可能崩溃的问题。 1.62.0 社区动态增加点赞功能 在「我的」页面可以将收获的点赞数兑换成魅力经验值 在「我的」页面可以将连续完成事项天数兑换成耐力经验值。 社区中的「时刻」页面添加自动过滤功能。 社区页面可以点击Tab回到最顶了。 修复一个因网络问题引起的崩溃问题。 性能优化，文案更改。 1.61.0 新增夜间模式。 新增「历史」页面的日期筛选功能。 新增「特性」页面展示更新内容和未来计划。 「显示设置」页面新增更改日期格式的设置。 待办事项页面滚动时，自动隐藏新增事项按钮。 修复部分Android版本应用内修改语言无效的问题。 修复暖启动时短暂黑屏，细节、性能优化。 1.60.8 修复因为混淆导致登录界面闪退的问题。 1.60.7 现支持重命名默认清单。 修复有时候图标显示不出来的问题。 优化提交崩溃报告的对话框。 采用混淆优化应用体积，提高运行效率。 部分界面开始采用MVP架构重构。 1.60.6 修复新建事项时候“开始时间数据异常”的问题 将隐藏事项页面头部的事项计数卡片改为持久性的，不再是临时性的了。 大幅度优化了主页、状态、历史等页面的性能表现。 1.60.5 修复逾期事项的清单分类可能变回默认清单的问题。 1.60.4 增加应用内语言更改。 设置(Settings)→显示设置(Display Settings)→语言设置(Language) 新建本地事项的开始时间新增了两个选项 自动调整（根据重复频次） 期限当天 自定义 现在支持隐藏事项页面头部的事项计数卡片。相应的也在右上角菜单加入了重新显示的选项。 修复了当编辑事项时，修改所属清单不生效的问题。 1.60.3 修复数个崩溃问题。 1.60.2 修复一些文本显示 1.60.1 修复了默认情况下，桌面小部件设置「隐藏非今日事项」显示勾选，实际未生效的问题。 1.60 添加了英文翻译 新增了 Google 授权登录 界面微调 1.59c 修复了提醒不正常的问题。 修复了在一些情况下，新建事项点击没反应的问题。 1.59b 修复 Android P 在桌面小部件完成时可能崩溃的问题。 1.59a 修复v1.59的桌面小部件完成时可能崩溃的问题。 1.59 现在支持滑动完成事项了。 新增「统一事项颜色」设置：将所有类型的事项统一为蓝色。 完成事项时底部弹框提供「撤销」选项。 「新建事项」页面可以选择「所属清单」了。 「排序」新增按「重复频次」排序选项。 优化了桌面小部件完成事项的实现方式，可能解决了一些问题。 「关于」页面新增「通过Android绿色应用公约认证」的链接。 现在新建事项时可以不选择相关属性，直接新建普通事项了。 1.58c 为了提前适配Android Q和遵守绿色应用公约，去掉了对读写外部存储权限的使用依赖。 修复放弃事项会让目标完成次数+1的逻辑问题。 修复选择艾宾浩斯记忆法的事项缺少最后一天的问题。（需要新建事项） 修复不能把事项编辑为艾宾浩斯记忆法的事项的问题。 修复编辑个人资料的一个崩溃问题。 1.58b 修复选择艾宾浩斯记忆法的事项开始时间异常的问题。 修复事项详情页面目标次数计数有误的问题。 1.58a 修复「状态」页面的步数兑换经验值“领取”按钮不可点击的问题。 修复删除历史记录后，「我的」的事项统计数据不会相应变化的问题。 1.58 增加事项详情页面。（可点击待办事项卡片或者历史页面的记录查看） 优化当事项备注过长时，待办事项卡片的显示效果。 优化大部分对话框的显示效果。 优化设置页面的显示效果，并且增加了选项说明文字。 新建待办事项页面，增加了各个设置项的指引说明。并且属性下方加上了名字。 新手指引增加清单和主页右上角的菜单选项（时间范围选择）的说明内容。 修复了当团队事项逾期后，自动领取下一次团队事项不会刷新页面的问题。 更换了新图标。 支持库迁移到了AndroidX。 修复了一个桌面小部件完成事项时的问题。 修复了一些崩溃、逻辑和内存泄露问题。 1.57a 修复当事项名较长时候的一些显示问题。 1.57 添加了「隐藏计步」的设置项。 调整了重复事项的处理逻辑：每次事项的持续时间将对应上重复频次。 修复了编辑事项的一些问题。 修复了两个罕见的崩溃问题。 去掉了手动输入计步数据的步数限制。 颜色微调。 1.56 重复频率增加”艾宾浩斯记忆法”选项。 （依次重复频率为当天→1天后→2天后→4天后→7天后→15天后） 优化待办事项卡片和桌面小部件的时间显示。 新增了本地数据的备份/恢复功能。 修复重置“团队截止加入日期”时的崩溃问题。 修复了一些情况下标题栏菜单错乱的问题。 一些界面优化。 1.55 修改了“放弃”操作的逻辑：不再会中断重复事项。 修复了编辑事项时候的“重置”按钮显示异常。 桌面小部件添加圆角。 修复服务器宕机时的程序崩溃，并且添加了提示。 服务器修复了 emoji 问题，在昵称、团队、动态等地方都能使用 emoji 了。（代价是丢失了一天的数据orz） 因为一些意外，3月3号服务器停止了服务近10个小时。 并且丢失了一小段时间的团队数据，很抱歉(:з」∠)。 丢失的部分团队事项应该无法完成，2号后第一次登陆的用户可能要重新登陆一遍，麻烦了。 1.54 修复因为网络原因没领取到下一次事项的问题（上次判断写错了orz） 修复一个崩溃问题 一些界面微调 1.53 「清单」新增了一个「所有清单」：可以查看所有清单的事项。 「提醒时间」加入了三个预设选项：期限前10分钟、期限前30分钟、期限前1小时。 修复桌面小部件只显示当前清单的问题。 「待办事项」和「状态」页面布局优化，理论上适配了任意宽度。（解决了当最低宽度为320dp的显示问题） 修复 QQ 授权登陆时获取失败昵称、头像的问题。 步数兑换力量经验值的奖励数值调低。 修复了右上角菜单错乱的问题。 一些页面的小修小改，属性图标进行了微调。 偷偷地加了个「捐赠」功能。 1.52功能： 「清单」分类功能： 新建清单 重命名清单 删除清单 事项的「移至」功能。 「历史」页面新增将逾期事项「设为完成」的功能（点击时间会弹出选项） 优化： 优化了对团队事项逾期的处理逻辑，防止出现因为网络原因没领取到下一次事项的情况。 优化了当团队名太长时，动态的布局显示。 修复了当重复点期限日期的「设置时间」时触发的一个问题。 优化了对登陆授权失效的处理。 修复了发表动态时的一个错误提示。 1.51 功能： 新增「期限日期」的「具体时间」设置，现在可以建立如“每天的4:00到第二天的4:00”周期事项。 当选择「重复频次」为「每日」的时候，新增了一个设置「星期几忽略」的功能。即可以设置如“每周一到周三”的周期事项。 设置里新增了「默认不发表团队动态」的选择项 「社区」的「时刻」新增了范围的选择，可以选择「所有」浏览社区的所有创建和完成事项的动态。 「排序」新增按拼音字母排序的功能。 优化： 待办事项页面新增了移除和新增的动画效果。 修复了完成事项后，桌面小部件没有立即刷新的问题。 修复了近七天步数统计柱形图的数据显示不全的问题。 修复了经验值收支详情页面的文字重叠问题。 「关于」页面的「检测更新」功能，检测到新的更新时，会弹出一个对话框说明更新内容，询问是否更新。 「自动重做逾期事项」加上了对单次事项的支持。 还有一些页面的小修小改和代码优化。 1.50 新增「统计」页面（替换掉原来的「消息」模块）：可以查看近七天事项完成数、经验值获取、经验值分布、每日步数等统计数据。 新增了「经验值收支详情」页面，可以查看经验值的变动详情。 新增了本地事项的「完成奖励」功能，可以自设事项的完成奖励。 新增了「手动输入每日步数」的功能。 优化了各个页面的工具栏标题显示。 优化了「历史」的加载方式，提升了加载速度。 优化了小部件的自动刷新间隔。 “登陆”→ “登录”。 1.49 紧急修复一个逾期事项重做的逻辑bug 增加了历史页面中记录的删除功能 1.48 增加了【隐藏社区和消息模块】的设置项 修复了【自动重做逾期事项】的一个逻辑问题：可能把团队事项当做本地事项来重做。 修复了历史页面的逾期事项不显示【重做】按钮的问题 1.47 增加了事项的【开始时间】选项 增加了事项的【显示所有事项】、【显示今日事项】、【显示近七天事项】的选项 增加了简单的【排序】功能（按开始时间、期限时间、创建时间或者经验值排序） 优化了新建事项的界面 修复了一个登陆后打开社区还要求登陆的问题 修复了社区的一个崩溃问题 1.46 增加了简单的新手指引功能 增加了一个默认开启的“自动重做逾期事项”的选项 新增事项页面增加了容错处理：选择重复周期后，会默认期限日期为当天 修复了重做时，期限日期不正确逻辑问题；以及在历史页面的“重做”按钮的显示逻辑问题 修复了在有事项逾期情况下，小部件可能导致应用崩溃的问题 修复了登陆界面的一个崩溃问题（还优化了按钮的字体位置） 修复了终止团队时的一个崩溃问题 1.45 增加了编辑团队的功能 增加了小部件的【白色字体和图标】的设置选项 增加了一个“常见问题”的侧边栏入口 优化了加载中和加载失败的图片显示 修复了一个可能导致团队头像为空的问题 修复了一个“退出登录”可能引起的问题 1.44 【功能】本地事项可以设置事项「目标次数」了 【优化】简单适配了一下全面屏 【优化】优化了小部件的隐藏事项的逻辑（从隐藏所有未开始事项改成隐藏非今日的事项） 【优化】默认不开启“状态”页面的波浪动画（开启可能导致页面卡顿和崩溃（？)） 【优化】修复了一个导致事项的字体颜色不正常的bug 【优化】排行榜可以直接进入个人主页 1.43 增加了小部件的【暗色主题】 增加了小部件的【隐藏未开始事项】的设置选项 修复了在完成团队事项、领取团队事项时，小部件不会自动刷新的问题 1.42 桌面小部件 优化了团队、动态列表的每次加载数量 稍微优化了计步器（只有步行检测传感器的时候也能计步了） 修复了单次和多次任务“重做”时崩溃的问题 修复了修改个人信息后，本地显示头像异常的问题 1.41: 功能： （本地）可以自定义重复频次 增加了一个“默认重复事项”的选项 其他： 修复了成就页面的一个逻辑bug 修复了当服务器在维护时，打开社区可能会应用崩溃的问题 修复了一个引起新建团队时崩溃的问题（弹出错误提示） 一些页面的细节优化 1.40： 解决了Android P不能QQ登陆的问题（昵称暂不能含emoji，这个要等服务器端修复） 解决了动态文本显示不全的问题]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#11 | 12/06 Android 桌面小部件]]></title>
    <url>%2Fpost%2Ff5d060f4.html</url>
    <content type="text"><![CDATA[制作小部件的途中也遇到了各种坑orz，而且网络上的各种文章都不详细，摸索了一两天才写完。 准备首先，直接使用AS新建一个APP WIDGET，进行各种配置。 之后如果想修改小部件的最低宽高可以参考这个表： 关键代码LifeUpWidget.kt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 override fun onUpdate(context: Context, appWidgetManager: AppWidgetManager, appWidgetIds: IntArray) &#123; // There may be multiple widgets active, so update all of them for (appWidgetId in appWidgetIds) &#123; updateAppWidget(context, appWidgetManager, appWidgetId) AppWidgetManager.getInstance(context).notifyAppWidgetViewDataChanged(appWidgetId, R.id.widget_list) &#125; &#125; override fun onEnabled(context: Context) &#123; // Enter relevant functionality for when the first widget is created &#125; override fun onDisabled(context: Context) &#123; // Enter relevant functionality for when the last widget is disabled &#125; override fun onReceive(context: Context, intent: Intent) &#123; super.onReceive(context, intent) if (intent.hasExtra(WIDGET_IDS_KEY)) &#123; val ids = intent.extras.getIntArray(WIDGET_IDS_KEY) this.onUpdate(context, AppWidgetManager.getInstance(context), ids) if (intent.getBooleanExtra("isShowToast", false)) ToastUtils.showShortToast("成功刷新") &#125; else if (intent.action == FINISH_TASK) &#123; val extras = intent.extras if (extras != null) &#123; if (extras.getBoolean("canBeFinish", false)) &#123; val taskId = extras.getLong("taskId") val teamId = extras.getLong("teamId") val item = todoService.getATodoItem(taskId) if (teamId == -1L) &#123; todoService.finishTodoItem(taskId) ToastUtils.showShortToast("成功完成事项") if (item?.taskFrequency != 0) todoService.repeatTask(taskId) &#125; else &#123; val activityVO = ActivityVO() item?.let &#123; teamNetworkImpl.finishTeamTask(it, activityVO) ToastUtils.showShortToast("成功完成事项") &#125; &#125; &#125; else &#123; ToastUtils.showShortToast("尚未到开始时间") &#125; WidgetUtils.updateWidgets(context)/* // Notify the widget that the list view needs to be updated. val mgr = AppWidgetManager.getInstance(context) val cn = ComponentName(context, LifeUpWidget::class.java) mgr.notifyAppWidgetViewDataChanged(mgr.getAppWidgetIds(cn), R.id.widget_list)*/ &#125; &#125; &#125; companion object &#123; const val WIDGET_IDS_KEY = "lifeupwidgetidskey" const val FINISH_TASK = "net.sarasarasa.lifeup.action.FINISH_TASK" private val todoService = TodoServiceImpl() internal fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) &#123; // Construct the RemoteViews object val views = RemoteViews(context.packageName, R.layout.life_up_widget) views.setTextViewText(R.id.appwidget_text, "今日事项 0/0") val intent = Intent(context, LifeUpRemoteViewsService::class.java) intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId) views.setRemoteAdapter(R.id.widget_list, intent) views.setEmptyView(R.id.widget_list, R.id.tv_empty) val finishTaskIntent = Intent(FINISH_TASK) finishTaskIntent.setClass(context, LifeUpWidget::class.java) val pendingIntent = PendingIntent.getBroadcast(context, 200, finishTaskIntent, PendingIntent.FLAG_UPDATE_CURRENT) views.setPendingIntentTemplate(R.id.widget_list, pendingIntent) val startActivityIntent = Intent(context, MainActivity::class.java) val startActivityPendingIntent = PendingIntent.getActivity(context, 0, startActivityIntent, PendingIntent.FLAG_UPDATE_CURRENT) views.setOnClickPendingIntent(R.id.iv_home, startActivityPendingIntent) val addItemIntent = Intent(context, AddToDoItemActivity::class.java) val addItemPendingIntent = PendingIntent.getActivity(context, 0, addItemIntent, PendingIntent.FLAG_UPDATE_CURRENT) views.setOnClickPendingIntent(R.id.iv_add, addItemPendingIntent) val man = AppWidgetManager.getInstance(context) val ids = man.getAppWidgetIds( ComponentName(context, LifeUpWidget::class.java)) val refreshIntent = Intent() refreshIntent.action = AppWidgetManager.ACTION_APPWIDGET_UPDATE refreshIntent.putExtra(LifeUpWidget.WIDGET_IDS_KEY, ids) refreshIntent.putExtra("isShowToast", true) val refreshPendingIntent = PendingIntent.getBroadcast(context, 199, refreshIntent, PendingIntent.FLAG_UPDATE_CURRENT) views.setOnClickPendingIntent(R.id.iv_refresh, refreshPendingIntent) val finishCnt = todoService.getTodayFinishCount() val taskCnt = todoService.getTodayTaskCount() views.setTextViewText(R.id.appwidget_text, "今日事项 $&#123;finishCnt&#125;/$&#123;taskCnt&#125;") // Instruct the widget manager to update the widget appWidgetManager.updateAppWidget(appWidgetId, views) &#125; &#125; LifeUpRemoteViewsService.Kt 1234567891011package net.sarasarasa.lifeup.serviceimport android.content.Intentimport android.widget.RemoteViewsServiceclass LifeUpRemoteViewsService : RemoteViewsService() &#123; override fun onGetViewFactory(intent: Intent?): RemoteViewsFactory &#123; return LifeUpRemoteViewsFactory(this.applicationContext, intent) &#125;&#125; LifeUpRemoteViewsFactory.Kt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package net.sarasarasa.lifeup.serviceimport android.content.Contextimport android.content.Intentimport android.os.Bundleimport android.view.Viewimport android.widget.RemoteViewsimport android.widget.RemoteViewsServiceimport net.sarasarasa.lifeup.Rimport net.sarasarasa.lifeup.converter.TodoItemConverterimport net.sarasarasa.lifeup.fragment.LifeUpWidgetimport net.sarasarasa.lifeup.fragment.LifeUpWidget.Companion.FINISH_TASKimport net.sarasarasa.lifeup.models.TaskModelimport net.sarasarasa.lifeup.service.impl.TodoServiceImplimport java.text.SimpleDateFormatimport java.util.*class LifeUpRemoteViewsFactory(context: Context, intent: Intent?) : RemoteViewsService.RemoteViewsFactory &#123; private val mList = ArrayList&lt;TaskModel&gt;() private val mContext = context private val todoService = TodoServiceImpl() override fun onCreate() &#123; mList.clear() mList.addAll(todoService.getUncompletedTodoList()) &#125; override fun getLoadingView(): RemoteViews? &#123; return null &#125; override fun getItemId(position: Int): Long &#123; return position.toLong() &#125; override fun onDataSetChanged() &#123; mList.clear() mList.addAll(todoService.getUncompletedTodoList()) &#125; override fun hasStableIds(): Boolean &#123; return true &#125; override fun getViewAt(position: Int): RemoteViews? &#123; if (position &lt; 0 || position &gt;= mList.size) return null val taskModel = mList[position] val rv = RemoteViews(mContext.packageName, R.layout.item_widget_list) var canBeFinish = true rv.setTextViewText(R.id.tv_title, taskModel.content) rv.setTextViewText(R.id.tv_exp, taskModel.expReward.toString() + "经验值") val cal = Calendar.getInstance() val simpleDateFormat = SimpleDateFormat("yyyy/MM/dd", Locale.getDefault()) val dateAndTimeFormat = SimpleDateFormat("yyyy/MM/dd HH:mm", Locale.getDefault()) val isTeamTask = when (taskModel.teamId) &#123; -1L -&gt; false else -&gt; true &#125; if (cal.timeInMillis &lt; taskModel.startTime.time) &#123; //还没到开始时间的时候 rv.setViewVisibility(R.id.tv_time, View.VISIBLE) rv.setViewVisibility(R.id.iv_time, View.VISIBLE) rv.setTextViewText(R.id.tv_time, dateAndTimeFormat.format(taskModel.startTime) + "开始 #" + TodoItemConverter.iFrequencyToTitleString(isTeamTask, taskModel.taskFrequency)) canBeFinish = false &#125; else &#123; //设置频次标识的颜色 if (taskModel.taskExpireTime != null) &#123; rv.setViewVisibility(R.id.tv_time, View.VISIBLE) rv.setViewVisibility(R.id.iv_time, View.VISIBLE) if (taskModel.teamId != -1L) &#123; rv.setTextViewText(R.id.tv_time, dateAndTimeFormat.format(taskModel.endTime) + "期限 #" + TodoItemConverter.iFrequencyToTitleString(isTeamTask, taskModel.taskFrequency)) &#125; else rv.setTextViewText(R.id.tv_time, simpleDateFormat.format(taskModel.taskExpireTime) + "期限 #" + TodoItemConverter.iFrequencyToTitleString(isTeamTask, taskModel.taskFrequency)) &#125; else &#123; rv.setViewVisibility(R.id.tv_time, View.INVISIBLE) rv.setViewVisibility(R.id.iv_time, View.INVISIBLE) &#125; &#125;/* val extras = Bundle() taskModel.id?.let &#123; extras.putLong("taskId", it) &#125; val finishTaskIntent = Intent() finishTaskIntent.action = LifeUpWidget.FINISH_TASK finishTaskIntent.putExtras(extras) rv.setOnClickFillInIntent(R.id.btn,finishTaskIntent)*/ val extras = Bundle() taskModel.id?.let &#123; extras.putLong("taskId", it) &#125; extras.putLong("teamId", taskModel.teamId) extras.putBoolean("canBeFinish", canBeFinish) val fillInIntent = Intent(FINISH_TASK) fillInIntent.putExtra("NUMBER", position) fillInIntent.setClass(mContext, LifeUpWidget::class.java) fillInIntent.putExtras(extras) rv.setOnClickFillInIntent(R.id.btn, fillInIntent) return rv &#125; override fun getCount(): Int &#123; return mList.size &#125; override fun getViewTypeCount(): Int &#123; return 2 &#125; override fun onDestroy() &#123; mList.clear() &#125;&#125; AndroidManifest.xml 在application中加入： 123456789101112131415&lt;receiver android:name=".fragment.LifeUpWidget"&gt; &lt;intent-filter&gt; &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt; &lt;action android:name="net.sarasarasa.lifeup.action.FINISH_TASK" /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name="android.appwidget.provider" android:resource="@xml/life_up_widget_info" /&gt;&lt;/receiver&gt;&lt;service android:name=".service.LifeUpRemoteViewsService" android:exported="false" android:permission="android.permission.BIND_REMOTEVIEWS"&gt;&lt;/service&gt; 坑点只支持一部分ViewA RemoteViews object (and, consequently, an App Widget) can support the following layout classes: FrameLayout LinearLayout RelativeLayout GridLayout And the following widget classes: AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextView ViewFlipper ListView GridView StackView AdapterViewFlipper 如果使用其他VIew的话，直接显示不出来。 WidgetProvier中设置ListView12345678910111213141516171819const val FINISH_TASK = "net.sarasarasa.lifeup.action.FINISH_TASK"//要在AndroidManifest中加上 &lt;action android:name="net.sarasarasa.lifeup.action.FINISH_TASK" /&gt;val views = RemoteViews(context.packageName, R.layout.life_up_widget)val intent = Intent(context, LifeUpRemoteViewsService::class.java)intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)views.setRemoteAdapter(R.id.widget_list, intent)//这里的EmptyView指的是R.layout.life_up_widget的一个view，在ListView为空的时候才显示出来//并不是单独的一个Viewviews.setEmptyView(R.id.widget_list, R.id.tv_empty)//如果你的ListView要发送Intent的话，这里要设置IntentTemplateval finishTaskIntent = Intent(FINISH_TASK)finishTaskIntent.setClass(context, LifeUpWidget::class.java)val pendingIntent = PendingIntent.getBroadcast(context, 200, finishTaskIntent, PendingIntent.FLAG_UPDATE_CURRENT)views.setPendingIntentTemplate(R.id.widget_list, pendingIntent) 然后在LifeUpRemoteViewsFactory.Kt的getViewAt方法中 123456789val extras = Bundle()taskModel.id?.let &#123; extras.putLong("taskId", it) &#125;extras.putLong("teamId", taskModel.teamId)extras.putBoolean("canBeFinish", canBeFinish)val fillInIntent = Intent(FINISH_TASK)fillInIntent.putExtra("NUMBER", position)fillInIntent.setClass(mContext, LifeUpWidget::class.java)fillInIntent.putExtras(extras)rv.setOnClickFillInIntent(R.id.btn, fillInIntent) 然后再在WidgetProvider的OnReceive中处理这个广播 1234567override fun onReceive(context: Context, intent: Intent) &#123; super.onReceive(context, intent) if (intent.action == FINISH_TASK) &#123; //Do something... &#125;&#125; 刷新ListView的数据 首先，重写onDataSetChanged方法 1234override fun onDataSetChanged() &#123; mList.clear() mList.addAll(todoService.getUncompletedTodoList())&#125; 然后在WidgetProvier恰当的地方调用notifyAppWidgetViewDataChanged方法 1AppWidgetManager.getInstance(context).notifyAppWidgetViewDataChanged(appWidgetId, R.id.widget_list) ##在应用中通知刷新 这是一个StackOverFlow中有人推荐的方法： 在 WidgetProvier 中： 12345678910111213const val WIDGET_IDS_KEY = "lifeupwidgetidskey"override fun onReceive(context: Context, intent: Intent) &#123; super.onReceive(context, intent) if (intent.hasExtra(WIDGET_IDS_KEY)) &#123; val ids = intent.extras.getIntArray(WIDGET_IDS_KEY) this.onUpdate(context, AppWidgetManager.getInstance(context), ids) if (intent.getBooleanExtra("isShowToast", false)) ToastUtils.showShortToast("成功刷新") &#125;&#125; 写一个工具类： 1234567891011121314151617181920212223package net.sarasarasa.lifeup.utilsimport android.appwidget.AppWidgetManagerimport android.content.ComponentNameimport android.content.Contextimport android.content.Intentimport net.sarasarasa.lifeup.fragment.LifeUpWidgetclass WidgetUtils &#123; companion object &#123; fun updateWidgets(context: Context) &#123; val man = AppWidgetManager.getInstance(context) val ids = man.getAppWidgetIds( ComponentName(context, LifeUpWidget::class.java)) val updateIntent = Intent() updateIntent.action = AppWidgetManager.ACTION_APPWIDGET_UPDATE updateIntent.putExtra(LifeUpWidget.WIDGET_IDS_KEY, ids) // updateIntent.putExtra(MyWidgetProvider.WIDGET_DATA_KEY, data) context.sendBroadcast(updateIntent) &#125; &#125;&#125;]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#10 | 11/03 Android图片选择、裁剪实现（8.0以及MIUI适配）]]></title>
    <url>%2Fpost%2F99671126.html</url>
    <content type="text"><![CDATA[不得不说MIUI是个大坑，在其他系统都能正常实现的时候，唯独MIUI出现了各种奇奇怪怪的状况。 最后上了第三方框架uCrop解决裁剪问题。 所需要的框架因为LitePal和MobSDK都需要对Application进行修改，所以最好实现自己的Application： EasyPermissions（负责处理运行时权限的处理） uCrop（一个图片裁剪框架） 关键代码运行时权限+对话框选择是拍照还是选择照片 Android6.0后，调用相机以及写入存储文件需要运行时申请权限，这里采用了 Google 官方的 EasyPermissions 框架来简化权限申请步骤。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private var avatarFileName = "avatar.jpg"private var avatarOriginFileName = "avatarOrigin.jpg"companion object &#123; private const val RC_CAMERA = 200 private const val CHOOSE_PICTURE = 0 private const val TAKE_PICTURE = 1&#125;override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;String&gt;, grantResults: IntArray) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults) EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this)&#125;/** * 显示修改图片的对话框 */@AfterPermissionGranted(RC_CAMERA)fun showChoosePicDialog() &#123; val builder = android.app.AlertDialog.Builder(this) builder.setTitle("修改头像") val items = arrayOf("选择本地照片", "拍照") builder.setNegativeButton("取消", null) builder.setItems(items) &#123; _, which -&gt; when (which) &#123; 0 // 选择本地照片 -&gt; &#123; val perms = arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE) if (EasyPermissions.hasPermissions(this, *perms)) &#123; val intent = Intent(Intent.ACTION_PICK)//返回被选中项的URI intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, "image/*")//得到所有图片的URI startActivityForResult(intent, CHOOSE_PICTURE) &#125; else &#123; EasyPermissions.requestPermissions(this, "需要文件写入权限", RC_CAMERA, *perms) &#125; &#125; 1 // 拍照 -&gt; &#123; val perms = arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.CAMERA) if (EasyPermissions.hasPermissions(this, *perms)) &#123; val openCameraIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE) val file = getAvatarFile(avatarOriginFileName) if(file.exists()) file.delete() val fileUri = getUriByOsVersion(file) openCameraIntent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri) openCameraIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION) openCameraIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION) startActivityForResult(openCameraIntent, TAKE_PICTURE) &#125; else&#123; EasyPermissions.requestPermissions(this, "拍照需要系统摄像头权限授权和文件写入权限", RC_CAMERA, *perms) &#125; &#125; &#125; &#125; builder.show()&#125; 对选择、裁剪成功等返回结果的处理 Android7.0 对 APP 内的文件共享做了限制，外部不能直接访问你的内部文件。 这里需要用到FIleProvier，具体的FileProvider的配置在下一小节。 123456789101112131415161718192021222324public override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; super.onActivityResult(requestCode, resultCode, data) if (resultCode == Activity.RESULT_OK) &#123; when (requestCode) &#123; // 对拍照返回的图片进行裁剪处理 TAKE_PICTURE -&gt; &#123; val imgUriSel = getUriByOsVersion(getAvatarFile(avatarOriginFileName)) cutImageByuCrop(imgUriSel) &#125; // 对在图库选择的图片进行裁剪处理 CHOOSE_PICTURE -&gt; cutImageByuCrop(data?.data) // 上传裁剪成功的文件 UCrop.REQUEST_CROP -&gt; &#123; data?.let &#123; uploadFile(it) &#125; &#125; // 输出裁剪 UCrop.RESULT_ERROR -&gt; &#123; val cropError = data?.let &#123; UCrop.getError(it) &#125; ToastUtils.showShortToast(cropError.toString()) &#125; &#125; &#125;&#125; 使用uCrop框架对指定的文件进行裁剪 uCrop 是一款很优秀的第三方裁剪框架，Bilibili的客户端也在使用。 一开始调用系统的裁剪的时候，出现过各种坑（比如MIUI用return-data的方式调用会报错，不用return-data有时候又拿不到返回值），于是才换用了这个。 1234567891011private fun cutImageByuCrop(uri: Uri?) &#123; val outputImage = getAvatarFile(avatarFileName) val outputUri = Uri.fromFile(outputImage) uri?.let &#123; UCrop.of(it, outputUri) .withAspectRatio(1f, 1f) .withMaxResultSize(256, 256) .start(this) &#125;&#125; 一个获得指定名字的[File]对象的私有方法 123456789101112private fun getAvatarFile(filename:String): File&#123; // 使用 APP 内部储存空间 val appDir = File(getExternalFilesDir(Environment.DIRECTORY_PICTURES).absolutePath, "Avatar") // 这句是使用外部存储空间的 //val appDir = File(Environment.getExternalStorageDirectory().absolutePath, "LifeUp") if (!appDir.exists()) appDir.mkdir() return File(appDir, filename)&#125; 根据系统api版本决定是用绝对路径还是用FileProvider获得Uri的私有方法 123456789private fun getUriByOsVersion(file:File):Uri&#123; val currentApiVersion = android.os.Build.VERSION.SDK_INT return if(currentApiVersion &lt; 24) &#123; Uri.fromFile(file) &#125; else&#123; FileProvider.getUriForFile(this, packageName + ".provider", file) &#125;&#125; 上传裁剪后的头像 12345678@Throws(IOException::class)fun uploadFile(data: Intent) &#123;val file = getAvatarFile(avatarFileName) val file = getAvatarFile(avatarFileName) LoadingDialogUtils.show(this) userNetwork.updateAvatar(file)&#125; 如果要调用系统内置的裁剪，部分代码： 1234567891011121314151617181920212223242526272829@Deprecated("use ucrop instead")fun cutImage(uri: Uri?) &#123; if (uri == null) &#123; Log.i("tip", "The uri is not exist.") &#125; tempUri = uri!! val intent = Intent("com.android.camera.action.CROP") //com.android.camera.action.CROP这个action是用来裁剪图片用的 intent.setDataAndType(uri, "image/*") intent.putExtra("crop", "true") // aspectX aspectY 是宽高的比例 intent.putExtra("aspectX", 1) intent.putExtra("aspectY", 1) // outputX outputY 是裁剪图片宽高 intent.putExtra("outputX", 256) intent.putExtra("outputY", 256) //intent.putExtra("return-data", true) //val appDir = File(Environment.getExternalStorageDirectory().absolutePath, "LifeUp") tempUri = Uri.parse("file://" + "/" + Environment.getExternalStorageDirectory().absolutePath + "/" + "LifeUp" + "/" + avatarFileName) intent.putExtra(MediaStore.EXTRA_OUTPUT, uri) intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString()) intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION) intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION) intent.putExtra("noFaceDetection", true) startActivityForResult(intent, CROP_SMALL_PICTURE)&#125; 最好通过将 return-data 设为 false，然后通过传递 uri ， 返回时通过 uri 获取 File 的方式来使用。 MIUI 好像在 return-data 设为 true，在 intent 返回 bitmap 的情况下会报错。 另外，即便在 return-data 设为 false 的时候，MIUI 仍然可能会出现保存失败的情况。可能原始文件和裁剪后文件的 uri 不能相同（纯猜测）。 FileProvider 配置在 AndroidManifest.xml 中加上： 12345678910&lt;!--FileProvider共享文件--&gt;&lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="net.sarasarasa.lifeup.provider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths"/&gt;&lt;/provider&gt; 在 res/xml/file_paths.xml 中加上： 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths&gt; &lt;files-path path="Android/data/net.sarasarasa.lifeup/files/Pictures/" name="Avatar" /&gt; &lt;external-path path="Android/data/net.sarasarasa.lifeup/files/Pictures/" name="Avatar" /&gt; &lt;external-files-path path="files/Pictures/Avatar" name="images"/&gt; &lt;root-path name="name" path="" /&gt;&lt;/paths&gt;]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Git]开发中途清理.igonore新增的忽略文件]]></title>
    <url>%2Fpost%2F9a4281e2.html</url>
    <content type="text"><![CDATA[中途修改.gitignore文件后，直接commit的话，以前git跟踪的文件就算添加进忽略里，依旧会跟踪变化。 获取.gitignore文件模板https://github.com/github/gitignore 删除已经跟踪的文件 修改.gitignore文件后，先进行一次commit操作。 git commit -m &quot;update .gitignore&quot; 然后，清空本地暂存区的内容： git rm -rf --cached . 再次添加跟踪文件： git add . 再进行一遍commit提交修改。 git commit -m &quot;delete files that should not be tracked&quot; 我本地测试的时候，似乎修改.gitigonore文件的操作和下面的操作要分属两个commit才能生效。 不过也有可能是操作问题，这里有待检验。 利用Rebase操作合并commit比如要合并从HEAD开始的最新的两个commit： 首先，用rebase指明要rebase的从HEAD开始数的版本数量： git rebase -i HEAD~2 在弹出的文本编辑器中，将后面那个commit前面的pick改成squash然后保存。 如果中途出现冲突中断的话，处理后，可以用以下命令继续： git add . git rebase --continue 最后会弹出一个文本编辑器，让你编辑合并后的commit的描述，修改后保存即可。 参考链接 (Git)合并多个commit Git:中途清理.gitignore 忽略文件]]></content>
      <categories>
        <category>技术</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#9 | 8/30 数据库+数据填充]]></title>
    <url>%2Fpost%2Fe7c566a6.html</url>
    <content type="text"><![CDATA[使用了Litepal作为数据库ORM框架，还有BRAVH来简化RecyclerView的适配器的写法。 这里记录下开发途中遇到的坑。 创建自己的Application类因为LitePal和MobSDK都需要对Application进行修改，所以最好实现自己的Application： 1234567891011import android.app.Applicationimport com.mob.MobSDKimport org.litepal.LitePal class LifeUpApplication : Application() &#123; override fun onCreate() &#123; super.onCreate() MobSDK.init(this) LitePal.initialize(this); &#125;&#125; LitePal最新版的一些用法实体类继承LitePalSupport而不是原先的DataSupport。 另外Kotlin的var会自动实现getter和setter： 12345678910111213141516171819202122232425262728import org.litepal.crud.LitePalSupportimport java.util.*data class TaskModel( var content: String, var remark: String, var taskExpireTime: Date?, var taskRemindTime: Date?, var relatedAttribute1: String?, var relatedAttribute2: String?, var relatedAttribute3: String?, var taskUrgencyDegree: Int, var taskDifficultyDegree: Int, var taskFrequency: Int, var userId: Int?, var isShared: Boolean, var taskType: Int?) : LitePalSupport() &#123; var id: Long? = null var taskId: Long? = null var createdTime: Long = 0 var updatedTime: Long = 0 var expReward: Int = 0 var endDate: Date? = null var taskStatus: Int = 0&#125; 而对数据库的操作方法也从调用DataSupport类的方法变成了调用LitePal类的方法。 如： 123fun getFirstAttribute(): AttributeModel? &#123; return LitePal.findFirst(AttributeModel::class.java)&#125; 其他的话，没什么不一样。 刷新RecyclerView数据需要注意的一个坑是，RecyclerView的Adapter用的List不能重新指向一个新的引用。 必须用回原本的引用更改数据，然后再调用notifyDataSetChanged()就能刷新数据了。 123456private fun refreshDataSet() &#123; mList.clear() mList.addAll(todoService.getUncompletedTodoList()) mAdapter.notifyDataSetChanged()&#125; 当返回或是切换Fragment刷新数据1234567891011override fun onResume() &#123; super.onResume() refreshDataSet() //刷新数据的操作&#125;override fun onHiddenChanged(hidden: Boolean) &#123; super.onHiddenChanged(hidden) if (!hidden) &#123; refreshDataSet() //刷新数据的操作 &#125;&#125; Lottie的动画回调调用多次的问题原本在Lottie的结束和取消回调里调用一个对话框的显示的方法，实际使用发现这个回调会被调用数次？（有时候1次，有时候2次，3次。很是诡异。） 解决方法自然是加个boolean值标识： 1234567891011121314151617181920212223242526var isEverShowDialog = falsemView.addAnimatorListener(object : Animator.AnimatorListener &#123; override fun onAnimationRepeat(p0: Animator?) &#123; &#125; override fun onAnimationEnd(p0: Animator?) &#123; if (!isEverShowDialog) &#123; showDialogAbbr(item) isEverShowDialog = true &#125; //refreshHeaderView(mHeaderView) &#125; override fun onAnimationCancel(p0: Animator?) &#123; if (!isEverShowDialog) &#123; showDialogAbbr(item) isEverShowDialog = true &#125; &#125; override fun onAnimationStart(p0: Animator?) &#123; &#125;&#125;) 获得经验值的进度条动画的实现讲真，这个小小的动画实现可能是我花费时间最长的一个小模块了。 首先要解决无论是3个属性都选择了，还是只选择了1个，2个都能正确显示的问题。 其次，需要计算获得经验值前的经验值与等级的占比，来正确显示ProgressBar（进度条）的进度。 还需要判断会不会升级，如果升级要将进度条置为0再进行下一步操作。 还要保证进度增长的时间是大概一致的。 还需要用到多线程来实现进度的缓慢增长。 等等…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091private fun doProgressOrigin(dialogView: View, item: TaskModel, index: Int) &#123; val relatedAttribute = when (index) &#123; 1 -&gt; item.relatedAttribute1 2 -&gt; item.relatedAttribute2 3 -&gt; item.relatedAttribute3 else -&gt; return &#125; if (relatedAttribute.isNullOrBlank()) return //完成前的 val nowExpTotal = when (index) &#123; 1 -&gt; attributeService.getAttributeExpByString(relatedAttribute ?: "") - item.expReward 2 -&gt; attributeService.getAttributeExpByString(item.relatedAttribute2 ?: "") - item.expReward 3 -&gt; attributeService.getAttributeExpByString(item.relatedAttribute3 ?: "") - item.expReward else -&gt; return &#125; var nowExp = nowExpTotal - attributeLevelService.getAttributeLevelByExp(nowExpTotal).startExpValue val levelMaxExp = attributeLevelService.getAttributeLevelByExp(nowExpTotal).endExpValue - attributeLevelService.getAttributeLevelByExp(nowExpTotal).startExpValue val progressBar = when (index) &#123; 1 -&gt; dialogView.npb_first 2 -&gt; dialogView.npb_Sec 3 -&gt; dialogView.npb_thr else -&gt; return &#125; progressBar.progress = nowExp * 100 / levelMaxExp var finalProgress = (nowExp + item.expReward) * 100 / levelMaxExp if (finalProgress &gt;= 100) &#123; //要升级的情况 thread = Thread &#123; try &#123; //先走到尾巴 val toMax = progressBar.max - progressBar.progress while (threadRunning == true &amp;&amp; progressBar.progress != progressBar.max) &#123; activity?.runOnUiThread &#123; progressBar.incrementProgressBy(if (toMax / 20 &gt; 0) toMax / 20 else 1) &#125; Thread.sleep(40) &#125; //升级，进度条重置为0 val newLevelModel = attributeLevelService.getAttributeLevelByExp(nowExpTotal + item.expReward) val textViewLevel = when (index) &#123; 1 -&gt; dialogView.tv_levelFirst 2 -&gt; dialogView.tv_levelSec 3 -&gt; dialogView.tv_expThr else -&gt; return@Thread &#125; activity?.runOnUiThread &#123; progressBar.progress = 0 textViewLevel.text = "LV$&#123;newLevelModel.levelNum&#125;" &#125; nowExp = nowExpTotal + item.expReward - newLevelModel.startExpValue val nextMaxExpTotal = newLevelModel.endExpValue val nextMaxExp = newLevelModel.endExpValue - newLevelModel.startExpValue finalProgress = nowExp * 100 / nextMaxExp Thread.sleep(40) while (threadRunning == true &amp;&amp; progressBar.progress != finalProgress) &#123; activity?.runOnUiThread &#123; progressBar.incrementProgressBy(if (finalProgress / 30 &gt; 0) finalProgress / 30 else 1) &#125; Thread.sleep(40) &#125; &#125; catch (e: InterruptedException) &#123; e.printStackTrace() &#125; &#125; thread?.start() &#125; else &#123; //不需要升级 thread = Thread &#123; try &#123; var progressToGo = finalProgress - progressBar.progress while (threadRunning == true &amp;&amp; progressBar.progress != finalProgress) &#123; activity?.runOnUiThread &#123; progressBar.incrementProgressBy(if (progressToGo / 30 &gt; 0) progressToGo / 30 else 1) &#125; Thread.sleep(40) &#125; &#125; catch (e: InterruptedException) &#123; e.printStackTrace() &#125; &#125; thread?.start() &#125; 自定义View对话框的宽和高用了网上各种改跟View，getWindow然后setLayout的方法通通行不通。 最后发现在自定义View的根View里加上android:minHeight和android:minWidth两个属性就好了。 ToolBar最右侧显示按钮图标其实那个按钮是OptionMenu里面的Item。 设置Menu的时候将app:showAsAction设为always就可以强制显示图标了。 Menu布局文件： 1234567891011&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" tools:context="net.sarasarasa.lifeup.activities.AddToDoItemActivity"&gt; &lt;item android:id="@+id/action_finish" android:icon="@drawable/ic_done_white_24dp" android:orderInCategory="100" android:title="完成" app:showAsAction="always" /&gt;&lt;/menu&gt; Activity代码： 12345678910111213141516override fun onCreateOptionsMenu(menu: Menu): Boolean &#123; menuInflater.inflate(R.menu.menu_add_to_do_item, menu) return true&#125;override fun onOptionsItemSelected(item: MenuItem): Boolean &#123; when (item.itemId) &#123; R.id.action_finish -&gt; &#123; if (check()) &#123; addItem(getItem()) &#125; return true &#125; else -&gt; return super.onOptionsItemSelected(item) &#125;&#125;]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#8 | 8/5 主界面+设置界面]]></title>
    <url>%2Fpost%2Fe55e992b.html</url>
    <content type="text"><![CDATA[效果图： #设置页面 感觉 Google 官方的实现方式有点繁琐，而且布局不是很美观。 于是选用自定义布局+框架实现。 https://github.com/jeff-sun/SettingView 首页的BottomNavigationView实现Fragment切换如果自己写就要判断逻辑然后加载Fragment，实现Hide和Show。 不困难但是很繁琐，还是套用框架： https://github.com/WakeHao/NavBar TabLayout只能响应滑动事件，不能响应点击事件的解决将父布局改成LinearLayout。 实现不同Fragment加载不同的Toolbar 首先将AppBarLayout的实现分别写在各个Fragment里面。 然后在Activity中写一个初始化toolbar的方法，参数为等会让Fragment传入的toolbar。 1234567891011fun initToolBar(toolbar: Toolbar) &#123; setSupportActionBar(toolbar) val toggle = ActionBarDrawerToggle( this, drawer_layout, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close) drawer_layout.addDrawerListener(toggle) toggle.syncState() nav_view.setNavigationItemSelectedListener(this)&#125; 然后在各个Fragment的onCreateView方法中调用这个方法： 12//设置toolbar(activity as MainActivity).initToolBar(view.findViewById(R.id.toolbar)) CardView阴影显示不全的解决原因是CardView默认的Wrap_content是不会包括阴影部分的。 所以可以加Padding，或者是使用 1app:cardUseCompatPadding="true" 来让阴影部分也算在CardView的实际面积里。 这样的话，你需要重新调整下View的大小以及间距等等。 点击EditText出现日期选择12345678910111213141516171819202122/** * 展示日期选择对话框 */private fun showDatePickerDialog() &#123; val c = Calendar.getInstance() DatePickerDialog(this, DatePickerDialog.OnDateSetListener &#123; _, year, monthOfYear, dayOfMonth -&gt; // TODO Auto-generated method stub dDDL.setText("$year/$&#123;monthOfYear + 1&#125;/$dayOfMonth") &#125;, c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH)).show()&#125;private fun initDDDL() &#123; dDDL.inputType = InputType.TYPE_NULL dDDL.onFocusChangeListener = View.OnFocusChangeListener &#123; _, hasFocus -&gt; if (hasFocus) showDatePickerDialog() &#125; dDDL.setOnClickListener &#123; showDatePickerDialog() &#125;&#125; 第一次点击的时候会触发FocusChange，第二次点击才会触发OnClick。 所以两个监听器都要设置。 单选框的写法1234567891011121314/** * 展示重复频次选择对话框 */private fun showRepeaterDialog() &#123; val items = arrayOf("不重复", "每日", "每两日", "每周", "每两周", "每月") val dialog = AlertDialog.Builder(this).setTitle("设置重复频次") .setSingleChoiceItems(items, iCheckedItemIndex, DialogInterface.OnClickListener &#123; dialog, index -&gt; iCheckedItemIndex = index et_repeat.setText(items[index]) dialog.dismiss() &#125;).create() dialog.show()&#125; 让ImageView变成灰色12345678910111213/** 将技能图标初始化为灰色 **/private fun initAbbrBtn() &#123; val cm = ColorMatrix() cm.setSaturation(0f) // 设置饱和度 val grayColorFilter = ColorMatrixColorFilter(cm) iv_strength.colorFilter = grayColorFilter // 如果想恢复彩色显示，设置为null即可 iv_learning.colorFilter = grayColorFilter iv_charm.colorFilter = grayColorFilter iv_endurance.colorFilter = grayColorFilter iv_vitality.colorFilter = grayColorFilter iv_creative.colorFilter = grayColorFilter&#125; 恢复的话将colorFilter设为null即可。]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初接触实际Spring Boot项目的小总结]]></title>
    <url>%2Fpost%2F687507b9.html</url>
    <content type="text"><![CDATA[先说下该项目用到的一些技术： Spring boot Maven lombok Jpa thymeleaf easypoi layui SQL Server 附加数据库时错误：拒绝访问 附加数据库失败，操作系统错误 5:”5(拒绝访问。)” 在相应的文件上，右键ー属性ー安全，给予Authenticated Users组完全权限。 然后尝试再次附加。 Controller的几种写法返回值返回StringString的内容就相当于ViewName。 返回@ResponseBodyMap&lt;String, Object&gt;于是方法体可以这样写： 1234Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;success&quot;, true);map.put(&quot;message&quot;, &quot;修改成功&quot;);return map; 适用于ajax的异步请求。 返回ModelAndView123456ModelAndView modelAndView = new ModelAndView();modelAndView.setViewName(&quot;/login&quot;);map.put(&quot;size&quot;, size);map.put(&quot;page&quot;, page);modelAndView.addObject(map);return modelAndView; 与上面一种方法类似，但是可以自由设置View。 参数HttpSession session可以直接获取到session。 假如session放入了一个user实例，前端可以这样获取： 1th:value="$&#123;session.user.userName&#125;"&gt; @RequestBody + 实体类能将前端传的json自动映射为一个实体类。 前端ajax写法： 12345678910111213141516171819202122$.ajax(&#123; url: "/user/login", type: 'post', dataType: 'json', data: JSON.stringify(param), contentType: "application/json; charset=utf-8", success: function (res) &#123; if (res.success) &#123; layer.msg(res.message); setTimeout(function () &#123; location.replace("/index"); //.跳转到登录后的页面 return false; &#125;, 400); //.延时跳转，显示登录成功的消息 &#125; else &#123; $("[name='userId']")[0].focus(); layer.alert(res.message, &#123;icon: 5&#125;); &#125; &#125;, error: function () &#123; layer.alert('操作失败！', &#123;icon: 5&#125;); &#125;&#125;); data可以自动转换表单项，也可以手动写： 1var data = &#123;"oldPassword": oldPassword, "newPassword": newPassword&#125;; @RequestParam如：@RequestParam(value = &quot;userName&quot;) String userName 那么请求方式该是原本的链接后面加上?userName=Ayagikei Model model获取model对象然后返回到前端页面。前端可以直接获取传入的东西。 JS获取YYYY-MM-DD格式的当天日期1234567891011var date = new Date();var nowMonth = date.getMonth() + 1,strDate = date.getDate(),seperator = "-";if (nowMonth &gt;= 1 &amp;&amp; nowMonth &lt;= 9) &#123; nowMonth = "0" + nowMonth;&#125;if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123; strDate = "0" + strDate;&#125;var res = date.getFullYear() + seperator + nowMonth + seperator + strDate; JS实现表格的展开/隐藏以下代码举例的是多个表单的情况，以ID进行区分：12345678910111213141516//隐藏/展开按钮$('.mine-hide-btn').click(function () &#123; var id = $(this).attr('data-id'); var classname = "trHidden" + id; if ($('.' + classname).attr("hidden") == "hidden") &#123; $('.' + classname).removeAttr("hidden"); $(this).text("隐藏"); &#125; else &#123; $('.' + classname).attr("hidden", "hidden"); $(this).text("展开"); &#125; return false;&#125;); 分页后端Controller返回一个Page对象即可。 Service（含模糊搜索的处理）1234Sort sort = new Sort(Sort.Direction.ASC, "id");Pageable pageable = PageRequest.of(page, size, sort);return userRepository.findAllByIdLike("%" + id + "%", pageable); RepositoryJpa只需要声明个方法即可： 1Page&lt;UserDO&gt; findAllByIdLike(String id, Pageable pageable); 前端内容展示用 th:each 遍历展示传来的Page对象的所有内容即可。 页面指示器1234567891011121314151617181920212223242526272829303132333435&lt;div class="page-wrap"&gt; &lt;ul class="pagination"&gt; &lt;!-- 到达第一页按钮 --&gt; &lt;span th:if="$&#123;datas.isFirst()&#125;"&gt; &lt;li class="disabled"&gt;&lt;span&gt;«&lt;/span&gt;&lt;/li&gt; &lt;/span&gt; &lt;span th:unless="$&#123;datas.isFirst()&#125;"&gt; &lt;li class="active"&gt;&lt;a th:href="@&#123;'/admin/user-list?page=0' + '&amp;search=' + $&#123;search&#125;&#125;"&gt;«&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;'/admin/user-list?page='+$&#123;datas.getNumber()-1&#125; + + '&amp;search=' + $&#123;search&#125;&#125;" th:text="$&#123;datas.getNumber()&#125;"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;/span&gt; &lt;!-- 当前页面 --&gt; &lt;li class="active"&gt;&lt;span th:text="$&#123;datas.getNumber()&#125;+1"&gt;1&lt;/span&gt;&lt;/li&gt; &lt;!-- 到达尾页按钮 --&gt; &lt;span th:if="$&#123;datas.isLast()&#125;"&gt; &lt;li class="disabled"&gt; &lt;span&gt;»&lt;/span&gt; &lt;/li&gt; &lt;/span&gt; &lt;span th:unless="$&#123;datas.isLast()&#125;"&gt; &lt;li&gt;&lt;a th:href="@&#123;'/admin/user-list?page='+$&#123;datas.getNumber()+1&#125; + '&amp;search=' + $&#123;search&#125;&#125;" th:text="$&#123;datas.getNumber()&#125;+2"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a th:href="@&#123;'/admin/user-list?page='+$&#123;datas.getTotalPages()-1&#125; + '&amp;search=' + $&#123;search&#125;&#125;"&gt;»&lt;/a&gt;&lt;/li&gt; &lt;/span&gt; &lt;!-- end of 到达尾页 --&gt; &lt;/ul&gt;&lt;/div&gt; &lt;!-- end of page-wrap div --&gt; 查询指定日期的数据举例为User表中Date字段为日期 Repository声明以下方法： 1List&lt;User&gt; findAllByUserIdAndDateGreaterThanEqualAndDateBefore(String userId, Date after, Date before, Sort sort); Service12345678910111213/** 查询某一天的订单 * 需要将 * Date变为当天的 yyyy-mm-dd 00:00:00 * Date2为第二天的 yyyy-mm-dd 00:00:00 */Calendar calendar = Calendar.getInstance();calendar.setTime(date);calendar.set(Calendar.MINUTE, 0);calendar.set(Calendar.HOUR, 0);calendar.set(Calendar.SECOND, 0);date = calendar.getTime();calendar.set(Calendar.DATE, calendar.get(Calendar.DATE) + 1);Date date2 = calendar.getTime(); EasyPoi所用到的工具类以及设置边框的方法FileUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import cn.afterturn.easypoi.excel.ExcelExportUtil;import cn.afterturn.easypoi.excel.ExcelImportUtil;import cn.afterturn.easypoi.excel.entity.ExportParams;import cn.afterturn.easypoi.excel.entity.ImportParams;import cn.afterturn.easypoi.excel.entity.enmus.ExcelType;import org.apache.commons.lang3.StringUtils;import org.apache.poi.ss.usermodel.Workbook;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.net.URLEncoder;import java.util.List;import java.util.Map;import java.util.NoSuchElementException;public class FileUtil &#123; public static void exportExcel(List&lt;?&gt; list, String title, String sheetName, Class&lt;?&gt; pojoClass, String fileName, boolean isCreateHeader, HttpServletResponse response) &#123; ExportParams exportParams = new ExportParams(title, sheetName); //设置边框Styler（注意这里） exportParams.setStyle(ExcelExportStyler.class); exportParams.setCreateHeadRows(isCreateHeader); defaultExport(list, pojoClass, fileName, response, exportParams); &#125; public static void exportExcel(List&lt;?&gt; list, String title, String sheetName, Class&lt;?&gt; pojoClass, String fileName, HttpServletResponse response) &#123; ExportParams exportParams = new ExportParams(title, sheetName); //设置边框Styler exportParams.setStyle(ExcelExportStyler.class); defaultExport(list, pojoClass, fileName, response, exportParams); &#125; public static void exportExcel(List&lt;Map&lt;String, Object&gt;&gt; list, String fileName, HttpServletResponse response) &#123; defaultExport(list, fileName, response); &#125; private static void defaultExport(List&lt;?&gt; list, Class&lt;?&gt; pojoClass, String fileName, HttpServletResponse response, ExportParams exportParams) &#123; Workbook workbook = ExcelExportUtil.exportExcel(exportParams, pojoClass, list); if (workbook != null) ; downLoadExcel(fileName, response, workbook); &#125; private static void downLoadExcel(String fileName, HttpServletResponse response, Workbook workbook) &#123; try &#123; response.setCharacterEncoding("UTF-8"); response.setHeader("content-Type", "application/vnd.ms-excel"); response.setHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode(fileName, "UTF-8")); workbook.write(response.getOutputStream()); &#125; catch (IOException e) &#123; throw new RuntimeException(e.getMessage()); &#125; &#125; private static void defaultExport(List&lt;Map&lt;String, Object&gt;&gt; list, String fileName, HttpServletResponse response) &#123; Workbook workbook = ExcelExportUtil.exportExcel(list, ExcelType.HSSF); if (workbook != null) ; downLoadExcel(fileName, response, workbook); &#125; public static &lt;T&gt; List&lt;T&gt; importExcel(String filePath, Integer titleRows, Integer headerRows, Class&lt;T&gt; pojoClass) &#123; if (StringUtils.isBlank(filePath)) &#123; return null; &#125; ImportParams params = new ImportParams(); params.setTitleRows(titleRows); params.setHeadRows(headerRows); List&lt;T&gt; list = null; try &#123; list = ExcelImportUtil.importExcel(new File(filePath), pojoClass, params); &#125; catch (NoSuchElementException e) &#123; throw new RuntimeException("模板不能为空"); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e.getMessage()); &#125; return list; &#125; public static &lt;T&gt; List&lt;T&gt; importExcel(MultipartFile file, Integer titleRows, Integer headerRows, Class&lt;T&gt; pojoClass) &#123; if (file == null) &#123; return null; &#125; ImportParams params = new ImportParams(); params.setTitleRows(titleRows); params.setHeadRows(headerRows); List&lt;T&gt; list = null; try &#123; list = ExcelImportUtil.importExcel(file.getInputStream(), pojoClass, params); &#125; catch (NoSuchElementException e) &#123; throw new RuntimeException("excel文件不能为空"); &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage()); &#125; return list; &#125;&#125; ExcelExportStyler.java这是设置边框线的一个Styler。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import cn.afterturn.easypoi.excel.export.styler.AbstractExcelExportStyler;import cn.afterturn.easypoi.excel.export.styler.IExcelExportStyler;import org.apache.poi.ss.usermodel.CellStyle;import org.apache.poi.ss.usermodel.Font;import org.apache.poi.ss.usermodel.Workbook;public class ExcelExportStyler extends AbstractExcelExportStyler implements IExcelExportStyler &#123; public ExcelExportStyler(Workbook workbook) &#123; super.createStyles(workbook); &#125; public CellStyle getHeaderStyle(short color) &#123; CellStyle titleStyle = this.workbook.createCellStyle(); Font font = this.workbook.createFont(); font.setFontHeightInPoints((short) 12); titleStyle.setFont(font); titleStyle.setBorderBottom((short) 1); titleStyle.setAlignment((short) 2); titleStyle.setVerticalAlignment((short) 1); return titleStyle; &#125; public CellStyle stringNoneStyle(Workbook workbook, boolean isWarp) &#123; CellStyle style = workbook.createCellStyle(); style.setBorderLeft((short) 1); style.setBorderRight((short) 1); style.setBorderBottom((short) 1); style.setBorderTop((short) 1); style.setAlignment((short) 2); style.setVerticalAlignment((short) 1); style.setDataFormat(STRING_FORMAT); if (isWarp) &#123; style.setWrapText(true); &#125; return style; &#125; public CellStyle getTitleStyle(short color) &#123; CellStyle titleStyle = this.workbook.createCellStyle(); titleStyle.setBorderLeft((short) 1); titleStyle.setBorderRight((short) 1); titleStyle.setBorderBottom((short) 1); titleStyle.setBorderTop((short) 1); titleStyle.setAlignment((short) 2); titleStyle.setVerticalAlignment((short) 1); titleStyle.setWrapText(true); return titleStyle; &#125; public CellStyle stringSeptailStyle(Workbook workbook, boolean isWarp) &#123; return isWarp ? this.stringNoneWrapStyle : this.stringNoneStyle; &#125;&#125; MD5Utils1234567891011121314151617181920212223242526272829303132333435import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MD5Utils &#123; /** * 可以把一段文字转换为MD * Can convert a file to MD5 * * @param text * @return md5 */ public static String encode(String text) &#123; try &#123; MessageDigest digest = MessageDigest.getInstance("md5"); byte[] buffer = digest.digest(text.getBytes()); // byte -128 ---- 127 StringBuffer sb = new StringBuffer(); for (byte b : buffer) &#123; int a = b &amp; 0xff; // Log.d(TAG, "" + a); String hex = Integer.toHexString(a); if (hex.length() == 1) &#123; hex = 0 + hex; &#125; sb.append(hex); &#125; return sb.toString(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 不定长度的单元格合并的前端展示以及导出前端展示重点就是rowspan要设为长度，同时第一个td要只出现一遍，所以要加个if限定。 12345678910111213&lt;span th:each="item,itemIter : $&#123;table&#125;"&gt; &lt;tr th:each="obj,objIter:$&#123;item.getPara()&#125;"&gt; &lt;td class="hidden-xs" th:text="$&#123;item.getId()&#125;" th:rowspan="$&#123;item.getParaSize()&#125;" th:if="$&#123;objIter.count == 1&#125;"&gt;112&lt;/td&gt; &lt;td class="hidden-xs" th:text="$&#123;objIter.count&#125;"&gt;段数&lt;/td&gt; &lt;td class="hidden-xs" th:text="$&#123;obj.getLeftMargin()&#125;"&gt;左边距&lt;/td&gt; &lt;td class="hidden-xs" th:text="$&#123;obj.getStartPoint()&#125;"&gt;开始点数&lt;/td&gt; &lt;td class="hidden-xs" th:text="$&#123;obj.getLength()&#125;"&gt;切割长度&lt;/td&gt; &lt;td class="hidden-xs" th:text="$&#123;obj.getEndPoint()&#125;"&gt;结束点数&lt;/td&gt; &lt;td class="hidden-xs" th:text="$&#123;obj.getRightMargin()&#125;"&gt;右边距&lt;/td&gt; &lt;td class="hidden-xs" th:text="$&#123;obj.getGzl()&#125;"&gt;工作令&lt;/td&gt; &lt;/tr&gt;&lt;/span&gt; 导出在需要合并的List上加注解： 1@ExcelCollection(name = "", orderNum = "1")]]></content>
      <categories>
        <category>技术</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魅族Flyme和华为EMUI真机调试看不到log的解决]]></title>
    <url>%2Fpost%2Fea1c38b.html</url>
    <content type="text"><![CDATA[Flyme 7打开设置 → 辅助功能 → 开发者选项 → 性能优化 → 高级日志输出，将其设为全部允许就好了。 选项藏得挺深，而且在设置中的搜索功能是搜索不到这个选项的。 EMUI没有EMUI实机，这是网传方法： 在拨号界面输入 ##2846579## 打开工程菜单，再将“LOG设置”中AP日志打开。 参考链接android studio中崩溃无法查看log？]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>技术</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#7 | 7/3 侧滑菜单+登陆界面]]></title>
    <url>%2Fpost%2Fc9dbbcf5.html</url>
    <content type="text"><![CDATA[效果图： 总体都是在AS自带的几个Activity上进行修改，但也遭遇了不少的坑。 侧滑菜单分割线不同Group之间会自动添加分割线，布局如下： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" tools:showIn="navigation_view"&gt; &lt;group android:id="@+id/grp_application" android:checkableBehavior="single"&gt; &lt;item android:id="@+id/nav_home" android:icon="@drawable/ic_home_black_24dp" android:title="主页" /&gt; &lt;item android:id="@+id/nav_history" android:icon="@drawable/ic_history_black_24dp" android:title="历史" /&gt; &lt;item android:id="@+id/nav_achievement" android:icon="@drawable/ic_stars_black_24dp" android:title="成就" /&gt; &lt;/group&gt; &lt;group android:id="@+id/grp_system" android:checkableBehavior="single"&gt; &lt;item android:id="@+id/nav_settings" android:icon="@drawable/ic_settings_black_24dp" android:title="选项" /&gt; &lt;item android:id="@+id/nav_about" android:icon="@drawable/ic_info_black_24dp" android:title="关于" /&gt; &lt;/group&gt;&lt;/menu&gt; 按钮图标来源Google在Github上有material design的图标仓库，内含矢量图和png以及ios可用的多种格式。 登陆界面采用ToolBar登陆界面的模板使用的是ActionBar，我们要手动改成Toolbar。 布局文件中添加： 12345678910111213&lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/AppTheme.AppBarOverlay"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/login_toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" app:popupTheme="@style/AppTheme.PopupOverlay" /&gt;&lt;/android.support.design.widget.AppBarLayout&gt; kt代码中添加： 1234setSupportActionBar(login_toolbar)//下面两句是启用Toolbar的Up按钮supportActionBar?.setDisplayHomeAsUpEnabled(true)supportActionBar?.setHomeButtonEnabled(true) Up的按钮的作用理应是：返回该活动的父级活动，有点类似于Windows中的向上操作。 所以是和返回（Back）操作是不同的。 正确的实现方式是在AndroidManifest.xml相应的Activity中添加父布局： 1android:parentActivityName=".activities.MainActivity" 取消自动打开软键盘默认情况进入Login Activity，会自动获取第一个输入框的焦点。 显得不方便以及不美观，在AndroidManifest.xml相应的Activity中添加： 1android:windowSoftInputMode="stateHidden|stateAlwaysHidden" 分割线的实现使用一个自定义宽高以及颜色的View实现，布局文件： 1234567891011121314151617181920212223242526272829303132333435363738&lt;android.support.constraint.ConstraintLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="128dp"&gt; &lt;View android:id="@+id/divider_left" android:layout_width="128dp" android:layout_height="1dp" android:background="@android:color/darker_gray" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;TextView android:id="@+id/textView3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginEnd="3dp" android:layout_marginStart="3dp" android:text="@string/login_or" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="@id/divider_right" app:layout_constraintStart_toStartOf="@id/divider_left" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;View android:id="@+id/divider_right" android:layout_width="128dp" android:layout_height="1dp" android:background="@android:color/darker_gray" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintTop_toTopOf="parent" app:layout_constraintVertical_bias="0.47" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 按钮显示图片123456789101112131415&lt;Button android:id="@+id/yiban_sign_in_button" style="?android:textAppearanceSmall" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginBottom="16dp" android:layout_marginTop="16dp" android:background="@color/yiban_btn" android:drawableLeft="@drawable/ic_yibanlogo" &lt;!-- 左侧显示的图片 --&gt; android:drawablePadding="72dp" &lt;!-- 文字与图片的间隔 --&gt; android:gravity="center_vertical" &lt;!-- 只垂直居中 --&gt; android:paddingStart="16dp" &lt;!-- 设置图片与左侧的Padding --&gt; android:text="@string/login_viaYiban" android:textColor="@color/white" android:textStyle="bold" /&gt; 默认似乎是文字在图片之外的空间内居中，而不是在按钮整个宽度居中。 为方便这里微调间距解决，理论上也可以重写Button解决。 Toolbar 深色水波纹 + 白色文字默认的ThemeOverlay.AppCompat.Dark.ActionBar是白色文字+白色水波纹，结果我们的背景色过于浅色，白色水波纹几乎看不见。 修改theme实现 123&lt;style name="AppTheme.AppBarOverlay" parent="ThemeOverlay.AppCompat.ActionBar"&gt; &lt;item name="android:textColorPrimary"&gt;@android:color/white&lt;/item&gt;&lt;/style&gt; 参考文章Material Design之 AppbarLayout 开发实践总结 - 简书 细说 AppbarLayout,如何理解可折叠 Toolbar 的定制 - CSDN博客 玩转AppBarLayout，更酷炫的顶部栏 - 简书 android官方侧滑菜单DrawerLayout详解 - 泡在网上的日子 色彩样式 - Material design 设计指南 - 简书 Material Design颜色表 — HTML颜色代码 Android Toolbar使用系统原生返回键，并改变其颜色，自定义图片替换系统原生返回键 - CSDN博客 怎么使用Toolbar之给Toolbar加上动画 - 简书 如何让所有 View 都可以带上点击的水波纹效果? - V2EX 为什么我的Material Design程序点击时没有波纹扩散效果 - 简书]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#6 | 6/19 Launch Screen]]></title>
    <url>%2Fpost%2Fa1903a1d.html</url>
    <content type="text"><![CDATA[当我们打开 app 的时候，可能会出现一段短暂的白屏或者黑屏界面，这个界面就是 Launch Screen。 Launch Screen是为了优化用户体验而存在的，一点击就出现一个界面，让用户有流畅的感觉。 然而，如果只是纯色的白或者黑，就有点丑了。 一般的做法是放logo以及标语。 Launch Screen 实际上是一种 Theme。 **所以我们可以用修改Theme的方式来自定义我们的Launch Screen。 我们实现的只显示logo的Launch Screen（可能会修改）： 新建SplashActivity1234567891011121314151617181920212223package net.sarasarasa.lifeup;import android.content.Intent;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;/** * Created by AyagiKei on 2018/6/19 0019. */public class SplashActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Intent intent = new Intent(this, WelcomeActivity.class); startActivity(intent); finish(); &#125;&#125; 注意，这里并不需要加载ContentView。 这个页面将作为我们的启动页面，作简单的判断然后跳转到其他Activity。 注册成启动Activity，更换Theme12345678910&lt;activity android:name=".SplashActivity" android:label="@string/app_name" android:theme="@style/AppTheme.SplashTheme"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 将SplashActivity设为启动Activity。更改AndroidManifest.xml： 同时将Theme设为AppTheme.SplashTheme，我们将在下一步创建这个Theme。 新建Theme在styles.xml文件中修改或添加： 123456789101112131415&lt;style name="AppTheme.NoActionBar"&gt; &lt;item name="windowActionBar"&gt;false&lt;/item&gt; &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;&lt;/style&gt;&lt;style name="AppTheme.TranslucentTheme" parent="AppTheme.NoActionBar"&gt; &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; &lt;item name="android:windowTranslucentNavigation"&gt;false&lt;/item&gt; &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt; &lt;item name="android:background"&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt;&lt;style name="AppTheme.SplashTheme" parent="AppTheme.TranslucentTheme"&gt; &lt;item name="android:background"&gt;@drawable/splash_layers&lt;/item&gt;&lt;/style&gt; 其实就是隐藏各种状态栏什么的，和我们引导页做的事情是一样的。 所以我们这里直接继承了引导页的Theme然后更改背景。 将背景设为@drawable/splash_layers，这个文件我们下一步再创建。 创建背景文件在drawable中创建splash_layers.xml： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@color/white" /&gt; &lt;item&gt; &lt;bitmap android:gravity="center" android:src="@mipmap/icon" /&gt; &lt;/item&gt;&lt;/layer-list&gt; 我们这里使用 layer-list 来作为我们的背景。 layer-list中，越后的item，图层越在上层。 当然，你也可以选择普通的图片作为背景图。 第一个item就是背景的白色。 第二个item就是我们的logo。 （这里引入的mipmap最好宽高相等？否则可能会出现奇怪的情况） 设置跳转12345678910111213141516171819202122232425262728293031323334353637383940package net.sarasarasa.lifeup;import android.content.Intent;import android.content.SharedPreferences;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;/** * Created by AyagiKei on 2018/6/19 0019. */public class SplashActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //判断是不是第一次打开应用 SharedPreferences sharedPreferences = getSharedPreferences("status", MODE_PRIVATE); boolean isFirst = sharedPreferences.getBoolean("isFirst", true); Editor editor = sharedPreferences.edit(); if (isFirst) &#123; //第一次进入的时候，跳转到引导页 Intent intent = new Intent(this, WelcomeActivity.class); startActivity(intent); finish(); editor.putBoolean("isFirst", false); editor.commit(); &#125; else &#123; //否则，进入主页面 Intent intent = new Intent(this, MainActivity.class); startActivity(intent); finish(); &#125; &#125;&#125; 我们使用SharedPreferences来保存用户是否是第一次打开APP，然后进行不同的Activity跳转。 参考文章https://www.jianshu.com/p/6a863fac3f58 https://antonioleiva.com/branded-launch-screen/ https://blog.csdn.net/u010386612/article/details/79039937 https://www.jianshu.com/p/a859b1250bcb https://juejin.im/post/58ad90518ac2472a2ad9b684 https://keeganlee.me/post/android/20150909 https://blog.csdn.net/qq_26650589/article/details/53738176]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#5 | 6/17 布局复用]]></title>
    <url>%2Fpost%2F7c1546cb.html</url>
    <content type="text"><![CDATA[我们之前做引导页的时候，是一个页面一个xml布局文件。 这些布局文件其实只有些许不同，只是加载的动画不同、TextView显示的文本不同，最后一页多了个按钮而已。 实际上，我们可以只用一个xml布局文件，然后在代码中实现各个页面的异化。 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public static class WelcomeFragment extends Fragment &#123; private static final String ARG_SECTION_NUMBER = "section_number"; private static final int[] arrAnimation = &#123;R.raw.done, R.raw.animated_graph, R.raw.trophy, R.raw.floating_cloud&#125;; private static final int[] arrTitleText = &#123;R.string.page1_title, R.string.page2_title, R.string.page3_title, R.string.page4_title&#125;; private static final int[] arrContentText = &#123;R.string.page1_content, R.string.page2_content, R.string.page3_content, R.string.page4_content&#125;; protected boolean isCreate = false; private View rootView; public WelcomeFragment() &#123; &#125; /** * 创建 WelcomeFragment 实例 * * @param sectionNumber 第几页 * @return WelcomeFragment */ public static WelcomeFragment newInstance(int sectionNumber) &#123; WelcomeFragment fragment = new WelcomeFragment(); Bundle args = new Bundle(); args.putInt(ARG_SECTION_NUMBER, sectionNumber); fragment.setArguments(args); return fragment; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; LottieAnimationView animationViews = null; int iPage = getArguments().getInt(ARG_SECTION_NUMBER); //rootView = inflater.inflate(arrFragment[iPage], container, false); rootView = inflater.inflate(R.layout.fragment_welcome_page, container, false); //根据页面设置动画、文本、背景颜色 animationViews = rootView.findViewById(R.id.animation_view); animationViews.setAnimation(arrAnimation[iPage], LottieAnimationView.CacheStrategy.None); TextView titleTextView = rootView.findViewById(R.id.title_text); titleTextView.setText(arrTitleText[iPage]); TextView contentTextView = rootView.findViewById(R.id.content_text); contentTextView.setText(arrContentText[iPage]); LinearLayout linearLayout = rootView.findViewById(R.id.linearLayout); linearLayout.setBackgroundColor(PAGE_COLOR[iPage]); Button button = rootView.findViewById(R.id.welcome_btn); //针对各个界面进行异化处理 //第一个页面在创建后不会执行setUserVisibleHint方法，所以要手动播放动画。 if (iPage == 0) &#123; animationViews.setPadding(DensityUtil.dp2px(this.getContext(), 25), 0, 0, 0); animationViews.playAnimation(); &#125; if (iPage == 3) &#123; titleTextView.setTextColor(0XFF000000); button.setVisibility(View.VISIBLE); &#125; else &#123; contentTextView.setTextColor(0XFFFFFFFF); &#125; isCreate = true; return rootView; &#125; ....&#125; 其实没什么好说的，就是找出各个要异化的View，然后进行异化（根据页面设置动画、文本、背景颜色）。 xml中的按钮默认隐藏，当为第四页的时候才设置为显示。 当然，xml的设置和代码有些不同。 这里有些坑： 代码中使用DP单位添加一个工具类DensityUtil： 123456789101112131415161718192021import android.content.Context;import android.util.TypedValue;public class DensityUtil &#123; /** * 根据手机的分辨率从 dp 的单位 转成为 px(像素) */ public static int dp2px(Context context, float dpVal) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpVal, context.getResources().getDisplayMetrics()); &#125; /** * 根据手机的分辨率从 px(像素) 的单位 转成为 dp */ public static int px2dip(Context context, float pxValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125;&#125; 在代码中使用默认Attr值这个较为繁琐，我直接使用曲线救国的方法。 XML中默认使用这个attr数值，然后代码中异化其他数值。 如果要在代码中使用，可以参考以下文章： http://solo.farbox.com/blog/how-to-get-value-of-attr-in-code http://oliveexcel.iteye.com/blog/2227992]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从领取Github教育礼包到DigitalOcean购买服务器]]></title>
    <url>%2Fpost%2F2d5d76b2.html</url>
    <content type="text"><![CDATA[本文首发于我的简书页面。 自己想要一台国外的服务器用作某些用途，恰好自己学校又提供了教育邮箱。于是就打算拿Github的教育礼包中DigitalOcean的50美元优惠码来使用一年。 不过根据网上的一些文章，途中也遇到了一些坑。 最后也顺利地在2018/6/11一天内搞定了。所以打算记录一下自己的全过程，以供大家参考。 你所需要准备的东西 Github 账号 一个教育邮箱（edu或者是edu.cn结尾都可以）如果没有的话，也可以用学生证之类的东西。不过我没试过。 一个PayPal账号（你需要至少支付5美元） 1 提交 Github 教育礼包申请在 https://education.github.com/pack 点击 Get Your Pack 随后填写相关信息： 最好使用教育邮箱申请，这样申请通过得比较快。如果你注册用的邮箱不是教育邮箱的话，要先去添加教育邮箱，并且验证一下。 最下方有个How do you plan to use GitHub？（你计划怎么用 Github ），简单的用英文描述一下就好。比如：I want to learn coding and try to make contribution to the community. 提交后，等待一段时间审核通过。就可以在这个页面看到你领取到的一大堆羊毛。 找到 DigitalOcean，获取你的优惠码。 2 注册DigitalOcean账号注册的过程我没有截图，这里简单的描述一下吧。 我是通过别人的邀请链接注册的，这样可以得到10美元的被邀请奖励，邀请人也能获得一定的奖励。这里贴一下我的邀请链接 ~ 注册途中需要绑定一个社交账号，可以绑定Facebook、Github还有Twitter账号。我选择的是选择绑定Github账号，授权一下就好了。 然后有一个步骤是要绑定信用卡或者用PayPal支付5美元。我没有信用卡，选择的是用PayPal支付5美元。 随后有一个审核阶段，可能要等上数个小时才能继续。 3 通过DigitalOcean审核并且兑换优惠码3.1 通过审核过了挺长一段时间，收到邮件说要填写一些额外的信息。 点击邮件那个链接，进去填一些信息：手机号码（国内手机号码前面需要+86），所在地、姓名（我直接打了中文），还有打算用DigitalOcean做些什么（简单描述即可）。 又过了好一段时间，收到了两封邮件。第一封是要确认PayPal支付。 简单回复： Hi,the paypal payment is an authorized payment. 第二封邮件： 简单回复： hi,i have replied to that email. 不久之后，就收到了解除了账号限制的邮件。 3.2 兑换优惠码理论上，在 Settings 里面的 Billing 应该会有一个兑换优惠码的地方。但是我怎么都找不到。 这时候就要找客服了。拉到页面最低端，点击Support。然后再拉到页面下面，点击Contact Support。 按以下图片所示填写表单： 过了大约半个小时，客服就有了回复： 至此，我们的账号已经就有了65美元余额。 50 优惠劵 + 10 邀请链接注册 + 5 Paypal支付 4 购买服务器并且连接上点击网站首页的 Create 中的 Droplets。 调整各种配置： 服务器所在地的选择可以先用这个网站测速。 创建后，你会收到一封内含服务器ip地址、用户名、密码的邮件。 接着我们就可以用 Putty 连接上服务器了。 会弹出一个警告框，选择是。然后进入终端，输入用户名和密码，然后设置新密码。 你就可以在里面为所欲为了~无论是搭建ss、搭建web服务器还是只是玩玩linux都可以。]]></content>
      <categories>
        <category>技术</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>云服务器</tag>
        <tag>技术</tag>
        <tag>DigitalOcean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#4 | 6/11 多语言]]></title>
    <url>%2Fpost%2F3ffb3959.html</url>
    <content type="text"><![CDATA[当你在页面布局文件中写死字符串（Hardcoding string）的时候，编译器会报一个警告，让你用@string替代。 @string就是让程序在运行状态，再去找相应的资源文件，加载其中的字符串内容。 而 Android 会在不同的情况下加载不同的资源文件，这就是我们实现多语言的基础。 最终效果： 新建中文字符串资源文件夹在 res/values 上右键点击New→Values Resource File 然后选择Locale，再选择zh:Chinese ， 设置多语言这里作一个小例子讲解。 假如，你在任一页面布局文件中有一个TextView设置如下： 123456789&lt;TextView android:id="@+id/message" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginStart="@dimen/activity_horizontal_margin" android:layout_marginTop="@dimen/activity_vertical_margin" android:text="Home" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; 为了让“Home”在中文环境中显示为“首页”，英文环境保持“Home”。 我们需要进行以下步骤： 第一步 写成@string形式也就是将 1android:text="Home" 改成 1android:text="@string/home" @string斜杆后面的home类似于变量名，你可以换成其他的字符串 第二步 设置中文的字符串映射在中文字符串资源文件夹（也就是res\values-zh）内新建一个strings.xml文件。 填入以下内容： 123&lt;resources&gt; &lt;string name="home"&gt;首页&lt;/string&gt;&lt;/resources&gt; 第三步 设置英文映射同理，我们直接在原先的res\values的strings.xml内新增以下内容即可： 1&lt;string name="home"&gt;Home&lt;/string&gt; 测试关于测试我没找到好的方法测试，直接调整系统语言，然后运行APP进行测试。 不过理论上也可以通过代码更改APP获取资源文件夹的路径，并且以此实现APP内语言修改功能。 以后再说吧~]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#3 | 6/8 自适应图标]]></title>
    <url>%2Fpost%2Feac283fe.html</url>
    <content type="text"><![CDATA[将开发日志#1做的图标加入到应用中，但是 Android O 加入了一个叫做 Adaptive Icons 的特性，为了适配这个性质稍微有点麻烦。 设置AndroidManifest.xml在 AndroidManifest.xml 的&lt;application后面加上 12android:icon="@mipmap/ic_launcher"android:roundIcon="@mipmap/ic_launcher" icon 指的是普通图标 roundIcon 指的是圆形图标 存入各个规格的PNG图片适配旧版本将 mipmap-hdpi、mipmap-mdpi、mipmap-xhdpi等各种规格的图片放入 res\ 中。 然后新建一个文件夹 mipmap-anydpi-v26，里面新建一个 ic_launcher.xml 文件。 文件内容如下： 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;background android:drawable="@drawable/ic_launcher_background" /&gt; &lt;foreground android:drawable="@drawable/ic_launcher_foreground" /&gt;&lt;/adaptive-icon&gt; 最后文件结构： 分离 SVG 前/背景利用矢量图编辑工具，将前景保存为 ic_launcher_foreground.svg，背景为ic_launcher_background.svg。 然后将 背景SVG 转换成 VectorDrawable 并且放到 res/drawable文件夹内： 直接在 AS 中 res/drawable文件夹上右键→ New →Vector Asset就能将 svg 转换成 VectorDrawable 并且放到里面了。 参考Adaptive Icons - Android O 自适应图标简单用法 理解 Android 的「自适应图标」]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#2 | 6/7 引导页]]></title>
    <url>%2Fpost%2F17b01d24.html</url>
    <content type="text"><![CDATA[继续鸽需求文档，突然想要开始敲 Android 端的代码。 本文主要涉及到： ViewPager + Fragment 组合使用 沉浸式状态栏 页面指示器框架 使用 Lottie 框架显示动画 ViewPager 的简单优化 ViewPager 背景色渐变 Android Studio 录制手机屏幕 先发一下最终效果： ViewPager + Fragment 组合使用引导页一般是多页设计，所以我们这里用到 ViewPager 来切换不同的 Fragment。 新建 Activity 的时候可以选择 Tabbed Activity 作参考。 里面实现了 ViewPager 和 Fragment 的组合使用。 毕竟不是教程文档，我们这里仅做简单解释。 首先是活动布局文件 activity_welcome.xml： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/main_content" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="net.sarasarasa.lifeup.WelcomeActivity"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/container" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior" /&gt; &lt;me.relex.circleindicator.CircleIndicator android:id="@+id/indicator" android:layout_width="match_parent" android:layout_height="48dp" android:layout_marginBottom="32dp" app:layout_anchor="@+id/container" app:layout_anchorGravity="bottom|center" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; Fragment 布局文件： 12345678910111213141516171819202122&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/linearLayout" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="center" android:background="#4FC3F7" android:orientation="vertical" android:paddingTop="25dp" tools:context="net.sarasarasa.lifeup.WelcomeActivity$WelcomeFragment"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Sample Text" android:textAlignment="center" android:textColor="#FFFFFF" /&gt;&lt;/LinearLayout&gt; 以下是Java代码部分： 实现自己的 Fragment 类： 123456789101112131415161718192021222324252627282930313233343536373839public static class WelcomeFragment extends Fragment &#123; private static final String ARG_SECTION_NUMBER = "section_number"; View rootView; public WelcomeFragment() &#123; &#125; public static WelcomeFragment newInstance(int sectionNumber) &#123; WelcomeFragment fragment = new WelcomeFragment(); Bundle args = new Bundle(); args.putInt(ARG_SECTION_NUMBER, sectionNumber); fragment.setArguments(args); return fragment; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; LottieAnimationView animationViews = null; switch (getArguments().getInt(ARG_SECTION_NUMBER)) &#123; case 1: rootView = inflater.inflate(R.layout.fragment_welcome_page1, container, false); animationViews = (LottieAnimationView) rootView.findViewById(R.id.animation_view); animationViews.setAnimation(R.raw.done, LottieAnimationView.CacheStrategy.None); break; case 2: rootView = inflater.inflate(R.layout.fragment_welcome_page2, container, false); ... //此处根据你的页数需求，可以加载不同的Fragment &#125; return rootView; &#125;&#125; 实现 FragmentPagerAdapter ： 12345678910111213141516171819public class SectionsPagerAdapter extends FragmentPagerAdapter &#123; private Fragment mCurrentPrimaryItem; public SectionsPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return WelcomeFragment.newInstance(position + 1); &#125; @Override public int getCount() &#123; return PAGE_NUMBER; //PAGE_NUMBER是声明的常量4，这里返回具体的页数即可。 &#125;&#125; 然后在 Activity 的 onCreate 方法中加入： 12345mSectionsPagerAdapter = new SectionsPagerAdapter(getSupportFragmentManager());mViewPager = (ViewPager) findViewById(R.id.container);mViewPager.setOffscreenPageLimit(0);mViewPager.setAdapter(mSectionsPagerAdapter); 沉浸式状态栏经过观察可以发现我们这样写布局，最上层就是 Fragment 。 只是将状态栏设成固定颜色的时候是行不通的，因为我们的多个页面不同颜色，滑动的时候状态栏颜色会是单独一块。 当然，解决办法很简单，只要将状态栏隐藏就可以了。 而且，我们不需要 ActionBar。 在 style.xml 中加入： 12345678910 &lt;style name="AppTheme.NoActionBar"&gt; &lt;item name="windowActionBar"&gt;false&lt;/item&gt; &lt;item name="windowNoTitle"&gt;true&lt;/item&gt; &lt;/style&gt;&lt;style name="AppTheme.TranslucentTheme" parent="AppTheme.NoActionBar"&gt; &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; &lt;item name="android:windowTranslucentNavigation"&gt;false&lt;/item&gt; &lt;item name="android:statusBarColor"&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt; 我们在这里新建一个 theme ，并且让他继承自 NoActionBar，然后设置状态栏为透明。 这样会出现一个小问题： 整个布局的内容会向上移动顶到状态栏。 我们只需要在最上层布局元素加一个 android:paddingTop=&quot;25dp&quot;即可。 页面指示器框架指的是下面的小圆点，指示当前页面。 Google 的库中没有提供直接的实现， 如果自己弄的话要控制每个圆点的大小颜色也挺繁琐的。 所以，第一步当然是找一找有没有现成的轮子。 我们使用的是一个轻量级的框架CircleIndicator。 使用方法也很简单： 首先添加 Gradle 依赖 123dependencies &#123; compile 'me.relex:circleindicator:1.2.2@aar'&#125; activity_welcome.xml 布局中添加： 12345678&lt;me.relex.circleindicator.CircleIndicator android:id="@+id/indicator" android:layout_width="match_parent" android:layout_height="48dp" android:layout_marginBottom="32dp" app:layout_anchor="@+id/container" app:layout_anchorGravity="bottom|center" /&gt; 修改一下onCreate方法内的关于ViewPager的代码： 1234mViewPager = (ViewPager) findViewById(R.id.container);CircleIndicator indicator = (CircleIndicator) findViewById(R.id.indicator);mViewPager.setAdapter(mSectionsPagerAdapter);indicator.setViewPager(mViewPager); //这句一定要在viewPager设置Adapter写 使用 Lottie 框架显示动画Lottie 是 Airbnb 出的一个开源动画框架，一个动画 json 文件就能在跨平台播放。 首先，添加Gradle依赖 123dependencies &#123; implementation 'com.airbnb.android:lottie:2.5.4'&#125; 这个依赖内间接依赖了， compile &#39;com.android.support:support-v4:27.1.1&#39;。 所以可能存在依赖冲突问题。可以统一版本来解决。 或是参考解决android gradle依赖中的冲突。 查阅官方文档，尝试添加动画。 最简单的使用方式就是将动画 json 文件放入 res/raw 中，然后在布局文件加入以下代码： 1234567891011&lt;com.airbnb.lottie.LottieAnimationView android:id="@+id/animation_view" android:layout_width="350dp" android:layout_height="350dp" android:layout_gravity="center" android:layout_marginTop="35dp" android:paddingStart="50dp" app:lottie_autoPlay="false" app:lottie_loop="true" app:lottie_rawRes="@raw/done" /&gt; 这里以放入的 json 文件名为 done.json 为例。 那么还有一个问题，动画 json 文件哪里来呢？ 可以用 AE 自己制作。 该网站上有开源供免费使用的 json 文件。 如果想要简单的修改颜色，可以用到 lottie-editor。 ViewPager 的简单优化我们直接这样使用动画会发现会严重掉帧，特别是中间的页面。 这是因为 ViewPager 会自动缓存旁边的页面，并且动画一直在播放（？）。 我们这里做一些简单的优化操作： 在 Activity 声明 private WelcomeFragment arrWelcomeFragment[];，并且在 onCreate() 的时候保存下来。不用每次都new一个。同时在适配器里重写destroyItem(ViewGroup container, int position, Object object)方法，然后在里面什么都不做，让其不会再自动销毁。 用代码的时候载入动画，同时将缓存策略设为 None。 123View rootView = inflater.inflate(arrFragment[iPage], container, false);animationViews = rootView.findViewById(R.id.animation_view);animationViews.setAnimation(arrAnimation[iPage], LottieAnimationView.CacheStrategy.None); 改变播放策略，在转到该页再从零开始播放动画。 将所有LottieAnimationView设为app:lottie_autoPlay=&quot;false&quot;。 在 Fragment 类中重写setUserVisibleHint(boolean isVisibleToUser)方法： 1234567891011121314151617181920212223242526/** * 通过 Fargment 的可见性控制动画的播放与暂停 * * @param isVisibleToUser */@Overridepublic void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); LottieAnimationView animationView = null; if (rootView != null) &#123; animationView = rootView.findViewById(R.id.animation_view); &#125; if (animationView != null) &#123; if (isVisibleToUser &amp;&amp; isCreate) &#123; //相当于onResume animationView.playAnimation(); &#125; else &#123; //相当于onPause animationView.cancelAnimation(); animationView.setFrame(0); &#125; &#125; &#125; 这里存在一个小问题，第一个 Fragment 在创建后不会调用这个方法。 所以第一个 Fragment 要在 onCreateView 的时候，就让她开始播放。 ViewPager 背景色渐变渐变效果的实现主要参考了别人的代码。 12345678910111213141516171819202122232425262728293031323334353637383940//ViewPager添加onPageChangeListener，实现颜色渐变效果mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; /** * ViewPager滑动回调方法 * @param position 页签[0 ~ 3] * @param positionOffset 页百分比偏移[0F ~ 1F] * @param positionOffsetPixels 页像素偏移[0 ~ ViewPager的宽度] */ @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; ArgbEvaluator evaluator = new ArgbEvaluator(); // ARGB求值器 int evaluate = 0x00FFFFFF; // 初始默认颜色（透明白） if (position == 0) &#123; evaluate = (Integer) evaluator.evaluate(positionOffset, 0XFF4FC3F7, 0XFFE4542F); // 根据positionOffset和第0页~第1页的颜色转换范围取颜色值 &#125; else if (position == 1) &#123; evaluate = (Integer) evaluator.evaluate(positionOffset, 0XFFE4542F, 0XFF9575CD); // 根据positionOffset和第1页~第2页的颜色转换范围取颜色值 &#125; else if (position == 2) &#123; evaluate = (Integer) evaluator.evaluate(positionOffset, 0XFF9575CD, 0XFFFFFFFF); // 根据positionOffset和第2页~第3页的颜色转换范围取颜色值 &#125; else &#123; evaluate = 0XFFFFFFFF; // 最终第3页的颜色 &#125; //找到Fargment元素设置背景色 for (int i = 0; i &lt; PAGE_NUMBER; i++) &#123; if (arrWelcomeFragment[i] != null &amp;&amp; arrWelcomeFragment[i].getView() != null) &#123; arrWelcomeFragment[i].getView().setBackgroundColor(evaluate); &#125; &#125; &#125; @Override public void onPageSelected(int position) &#123; &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125;&#125;); Android Studio 录制手机屏幕一直没注意到 AS 有录制屏幕的功能，这次打算做 gif 的时候用到了。 搜索了一下说是在下方的 Monitor，但是找了半天没找到。 原来是改名为 Logcat 了。 具体位置在这里： Push 到 Github 时遇到的小问题解决一开始配置完 Git 和 Github 之后，发现 push 会失败。 这时候要去 Setting → Git SSH executable 设为 Native。 就解决了。 部分参考推荐4个Android引导页框架 解决android gradle依赖中的冲突 Android - ViewPager进阶篇之渐变背景色 ViewPager使用详解(二):FragmentPagerAdapter]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人升开发日志#1 | 6/1 APP 图标设计]]></title>
    <url>%2Fpost%2F1188c9f1.html</url>
    <content type="text"><![CDATA[名字由来初想过的项目名是“升级人生”、“游戏人生”之类，就想到了以”人“字为原型设计 APP 图标。 仅有一个”人“字未免显得有些单调，于是乎想到”升“字，那么就把”人“字的两笔换成向上升的形态？ APP 图标就由此诞生了。 最终稿是这个样子的： 接下来说说设计的全过程吧。 绘制格式选择以及工具图标的绘制一般选用矢量图，原因： 图标一般需要多种规格，矢量图不失真方便调整 图标一般形状简单，矢量图绘制更为方便 具体用什么格式呢？ 我们采用了 svg 格式。 第一个原因是，Android 支持将 SVG 转换成 VectorDrawable。今后开发可能会用到。 第二个原因是， 我们设计的图标期望是 Material Design 设计风格的。 而我所想到的就是拥有着朝向右下角阴影风格的图标，也就是最终稿那个样子。 而且没有检索到具体要怎么做到这种效果，也没有找到这种效果具体的名称。 只模糊地得知可以利用路径的并且差操作做到？ 不过，我找到了一个可以简单生成这种风格的网页工具，该网站上传的文件必须是 SVG 格式。 那么，该用什么矢量图绘制工具呢？ 首先想到的当然是 Adobe 的 illustrator； 其次，我想到之前做 Android APP时候用到的一款免费开源的矢量图绘制工具 Inkscape 。 最后决定用 Inkscape，方便快捷而且符合操作习惯。 开始绘制首先，先造个“人”字。 首先想到用字符转换矢量图路径，但可能不太适用？很快就放弃了这个想法。 然后尝试了一下用钢笔工具（在 inkscape 里，被称作「绘制贝塞尔曲线和直线」工具）绘制，发现不会用emm。 最后采用了「绘制手绘线」工具，将平滑调整到最高，一次画一条边，勉勉强强画了一个「“人”形 with 两个箭头 」出来。 接着，使用「选择并变换工具」 以及 「通过节点编辑路径」工具进行微调，删除不需要的路径节点，调整曲率等等。 最后封闭路径填充任意一种颜色。 MD风格图标生成器，启动！无限转圈…MD风格图标生成器，关闭！ 经过测试，发现刚画出来的稿子可以生成，微调之后的不能生成。 而且，此时是没有错误提示的？ 按F12调出开发者工具，可以看到 js 文件执行过程中抛了个异常。 当时还随手画了一个路径拿去测试： 问题发现，开始清除最后发现问题在于必须存在单条封闭路径。 而我们的矢量图虽然有封闭路径，但其是由多条路径组成的。 也就是说用「通过节点编辑路径」可以看到路径是断开的。 解决方法也很简单：选中所有路径然后点击菜单中的路径→合并即可。 配色导入之后，可以进行颜色位置之类的调整。 打算采用蓝白配色，在一个MD配色网站挑选具体的RGB值，最后采用的是#29b6f6。 因为是亮蓝色，所以阴影强度也要适度调低。 位置的话，一开始想的是左边元素较多，所以稍微偏右。 然后发现实际效果似乎还不如直接居中，于是就采用了居中。 新增元素做着做着的时候（其实是遇到坑的时候），又浮现了另外一个想法： 以阶梯做图标，还可以加上一个上阶梯的小人。 因为绘制小人不太容易，于是从现有的图标库中检索。 我们使用的是iconfont，检索关键字为楼梯。 最后也就是这个样子： 后来，我们打算将这个小人加到我们的图标上。 做法是，在网站生成的svg上进行再修改： 首先要把小人抠出来。 摸索出的一个做法是，使用「擦除现有路径」工具，擦出一条边界，然后使用菜单菜单中的路径→分离，最后使用「通过节点编辑路径」工具，删掉擦除出现的一堆节点，使边缘平滑。 将我们的 svg 进行分图层处理，将小人放到图案和背景圆之间。 使用滤镜，添加小人阴影。 最终效果： 当然，问题又来了： 小人和图案的阴影并不统一。 砍掉重做为了解决这个问题，在上传到那个网站工具之前，就要把小人加到图标中。 再次抠图，将小人放到合适的位置。 然后全选，使用菜单中的路径→并集和分离工具， 再次上传到网站中。 此时，阴影已经统一了： 加一级层次也曾纠结要不要去掉左边的箭头，因为去掉之后更像“人”字，而且左侧的箭头有种会阻碍小人上行的感觉？ 纠结一番后决定，把小人所在的箭头提升一个层次，就不存在阻碍感了。 具体地来说就是加一层阴影。 因为我们一开始是没有分图层的，所以要单独把箭头抠出来。 我们采用的做法是 先复制整个图案（不含阴影）到新的一个图层里。 然后用「擦除现有路径」工具，用跟之前类似的方法把箭头和小人抠出来，并且加上一层阴影。 这就得到我们的最终稿了。 最后再依次导出各个规格即可。]]></content>
      <categories>
        <category>项目</category>
        <category>开发日志</category>
        <category>人升</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将Ubuntu装入U盘,打造便携系统]]></title>
    <url>%2Fpost%2F4d0e5331.html</url>
    <content type="text"><![CDATA[前段时间想要尝试下 Ubuntu 系统，又不太想弄双系统，后来想了想干脆将 Ubuntu 装入一个空闲的 U 盘里面，实现即插即用的便携系统与工作环境。 准备工作 闲置的 U 盘建议至少支持USB3.0，空间至少16G以上，32G为佳。 虚拟机或是另外一个闲置U盘 用来当启动盘安装 Ubuntu。这里选择的是 Vmware Workstation 14 Pro。 Ubuntu Desktop 系统安装文件在Ubuntu官网下载，这里选择的是Ubuntu Desktop 18.04 LTS。 新建虚拟机启动 Vmware ，文件新建虚拟机典型稍后安装系统Linux Ubuntu。 最大磁盘大小设为最小（1G）即可，我们是用虚拟机来安装系统，并不需要硬盘空间。 接着一路下一步，创建出一个虚拟机。 右键你新建的虚拟机，点击设置。 将 CD/DVD 设为你下载的 Ubuntu Desktop 系统安装文件（iso文件）。 同时最好打上已连接和启动时连接两个勾。 安装系统插上 U 盘，启动虚拟机。 没有意外的话，你能看到 Ubuntu 的安装界面。 选择安装Ubuntu，注意此时的 U 盘应该与虚拟机相连接。 如果没有连接的话，点击以下图片所示的按钮： 注意要安装到 U 盘里，其他的按照需求进行点击安装即可。 分区的话这里将根目录 &#39;/&#39; 挂载为最大的空间，/boot空间设为了300MB，swap空间设为了2GB。 可按需求自行修改，注意下方的安装启动引导器的设备一定要设置为你的 U 盘。 启动系统实机启动的话，只需要进入 bios ，将 Removable Devices 设为优先启动即可。 我们这里讲讲怎么用虚拟机启动你的 U 盘里的系统。 进入虚拟机设置，添加硬盘使用物理硬盘。 在下一步的设备中选择最后一项（一般 U 盘是最后一项）。 点击如下图所示按钮进入虚拟机的bios： 接着更改启动优先级到下图所示状态： 最后，重新启动你的虚拟机，就能进入你的 Ubuntu 系统了。 此时要保证断开虚拟机与 U 盘的连接，应与主机连接。 确保是以下状态，不要点击： What’s Next?接下来当然是安装程序，捣鼓你的 Ubuntu 去啊。]]></content>
      <categories>
        <category>技术</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>linux</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 常用软件清单]]></title>
    <url>%2Fpost%2F3d99d1b6.html</url>
    <content type="text"><![CDATA[归档一下自己一些常用的软件。 图片软件 CollageIt 图片拼接软件 Inkscape 免费的矢量图（SVG）编辑工具 文本软件 Notepad++ Beyond Compare 文本对比 Typora Markdown编辑器 音频 GoldWave 视频 格式工厂 屏幕录制 Bandicam 搜索 Everything 截图 Snipaste 串流 Splashtop Anydesks 虚拟机 VMware Workstation]]></content>
      <categories>
        <category>计算机</category>
        <category>软件</category>
        <category>清单</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>清单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器CentOS搭建Minecraft服务器]]></title>
    <url>%2Fpost%2Fd8f0add3.html</url>
    <content type="text"><![CDATA[前期准备购买云服务器本文选择的是阿里云+CentOS。 安装 Java 环境首先使用以下命令来分别检查 java 和 jdk 的安装状况。 12java -versionrpm -qa | grep jdk 如果没有安装的话，可以用yum方式安装：1yum -y install java-1.8.0-openjdk* 开启端口CentOS 7.0以上版本，内置防火墙从 iptables 替换成了 firewalld。所以你要根本版本选择不同的设置方式。 Firewalld 首先查看已经开放的端口 1firewall-cmd --zone=public --list-ports ​ 分别开启 22 和 25565 端口 12firewall-cmd --zone=public --add-port=22/tcp --permanentfirewall-cmd --zone=public --add-port=25565/tcp --permanent 注：22 是为了后面的 SSH 连接服务器，25565 是MC默认采用的端口。 重启防火墙，使更改生效 1firewall-cmd --reload ​ iptables 首先查看已经开放的端口 1/etc/init.d/iptables status ​ 分别开启 22 和 25565 端口 12iptables -A INPUT -p tcp --dport 22 -j ACCEPT iptables -A INPUT -p tcp --dport 25565 -j ACCEPT 注：22 是为了后面的 SSH 连接服务器，25565 是MC默认采用的端口。 ​ 重启防火墙，使更改生效 12/etc/rc.d/init.d/iptables save/etc/init.d/iptables restart 当然，你还能手动打开文件进行修改：vi /etc/sysconfig/iptables，然后在里面添加一句-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT来开启22端口。 阿里云控制台开启端口其次，你还要在阿里云的配置安全组设置。 登陆之后，选择你的云服务器 ECS更多安全组配置配置规则添加安全组规则 如下图填入规则信息： MC服务器默认用的端口号是25565，也可以改成别的 远程连接以及文件传输我用的是一款叫做 SSH Secure Shell Client的软件，它本身可以实现SSH连接，同时又具有可视化文件传输的功能。 但是在 SSH 官网这款软件似乎改名了，而且变成付费软件了。 可以尝试更换 PuTTY 软件进行远程连接，FIleZilla软件进行文件传输。 这些软件操作都类似，输入你的服务器公网IP地址，22端口，系统用户名和密码就可以登入了。 环境配置服务器文件在 官网 可以下载到Minecraft的纯净服务器端。 将 jar 文件上传（利用上一节所述软件）到服务器端，最好专门建一个文件夹放置，以MC为例。 然后开始尝试启动服务器吧： 12cd /root/MCjava -jar server.jar 你会发现运行过程中生成了一些配置文件，同时让你去同意 eula 协议才能继续。 编辑新生成的 eula.txt 文件，将其中的 eula=flase 改成 eula=true。 随后可以打开 server.properties 文件进行服务器配置。 将 online-mode=true 改成 online-mode=false 后非正版玩家才可进入服务器。 其他的可按需求修改，比如可以修改最大玩家量max-players、游戏模式gamemode、服务器端口server-port、待机踢出时间player-idle-timeout、服务器名称 motd 等。 服务器启动测试使用以下命令就可以启动服务器了： 1java -Xmx1024M -Xms1024M -jar server.jar nogui -Xmx参数是设置最大内存量、-Xms是最小内存量，根据你的服务器配置进行调节。 最好起码1G以上。 随后就可以测试能不能用服务器公网IP+端口号连接服务器了。 如果使用默认端口号的话就是xxx.xxx.xxx.xxx:25565 挂载后台你会发现用上述方式运行的服务器，当你的远程终端软件断开之后，服务器也会随之关闭。 你可能会想到用nohup命令挂载后台： 1nohup java -Xmx1024M -Xms1024M -jar server.jar nogui&amp; 一开始我这样是没有问题的，但是设置 op 之后，用这个命令运行的服务器会抛出一个异常。 我们这里采用 screen 来解决这个问题。 安装： 1yum install screen 使用方法： 新建窗口（注意-S必须是大写的） 1screen -S mc 运行服务器 会话分离 输入CTRL+A、CTRL+D 自动重启服务器脚本新建一个 startmc.sh文件，并在其中输入 1234while truedo java -Xmx1024M -Xms1024M -jar server.jar noguidone 然后运行服务器的时候执行这个脚本即可 1bash startmc.sh]]></content>
      <categories>
        <category>技术</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>云服务器</tag>
        <tag>技术</tag>
        <tag>游戏</tag>
        <tag>linux</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次WIN10更新后无法调整亮度的解决]]></title>
    <url>%2Fpost%2Fe5de8f7e.html</url>
    <content type="text"><![CDATA[晚上关机时，WIN10推送了一次更新。 第二天发现不是平时的亮度，同时右下角的电源配置里面的亮度设置变成灰色，不能按了。 查询并测试了以下方法都无法解决： 重启 修改注册表：HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class{4d36e968-e325-11ce-bfc1-08002be10318}；将0000和0001中的KMD_EnableBrightnessInterface2的值改为0。（REG_DWORD类型） 回滚显卡驱动 自动检查显卡驱动更新 最后发现问题似乎是出于远程控制软件（Splashtop）所安装的驱动，打开设备管理器→监视器里面可以看到远程控制软件安装的“虚拟”硬件。 一开始我尝试禁用设备，并没有效果。 最后直接卸载设备，监视器里面的硬件变回了通用即插即用监视器，重启，亮度设置就回来了。:D 不过下次使用远程控制软件的时候可能要重装了。 估计原因是把那个“虚拟”硬件当作是主显示器，然后就无法调节亮度。]]></content>
      <categories>
        <category>技术</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>系统</tag>
        <tag>记录</tag>
        <tag>WIN10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java DFS+贪心解决骑士游历问题]]></title>
    <url>%2Fpost%2Fa3a124b6.html</url>
    <content type="text"><![CDATA[题目 骑士游历 骑士游历问题是指，在国际象棋的棋盘（8行*8列）上，一个马要遍历棋盘，即走到棋盘上的每一格，并且每隔只到达一次。设码在棋盘的某一位置（x,y）上，按照“走马日”的规则，下一步有8个方向走，如图所示。若给定起始位置（x0,y0）,使用站和队列探索出一条马遍历棋盘的路径。 8 1 7 2 马 6 3 5 4 回溯枚举解法 这道题的解法思路和走迷宫类似。 首先是新建一个8个方向移动的结点类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package lab3.Knight;/** * @author AyagiKei * @url https://github.com/Ayagikei **/public class Point &#123; private int x,y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; public Point moveNE()&#123; if(this.getX()-2 &lt;1 || this.getY()+1 &gt;8) return null; return new Point(this.getX()-2,this.getY()+1); &#125; public Point moveEN()&#123; if(this.getX()-1 &lt;1 || this.getY()+2 &gt;8) return null; return new Point(this.getX()-1,this.getY()+2); &#125; public Point moveES()&#123; if(this.getX()+1 &gt; 8 || this.getY()+2 &gt;8) return null; return new Point(this.getX()+1,this.getY()+2); &#125; public Point moveSE()&#123; if(this.getX()+2 &gt; 8 || this.getY()+1 &gt;8) return null; return new Point(this.getX()+2,this.getY()+1); &#125; public Point moveSW()&#123; if(this.getX()+2 &gt; 8 || this.getY()-1 &lt;1) return null; return new Point(this.getX()+2,this.getY()-1); &#125; public Point moveWS()&#123; if(this.getX()+1 &gt; 8 || this.getY()-2 &lt;1) return null; return new Point(this.getX()+1,this.getY()-2); &#125; public Point moveWN()&#123; if(this.getX()-1 &lt; 1 || this.getY()-2 &lt;1) return null; return new Point(this.getX()-1,this.getY()-2); &#125; public Point moveNW()&#123; if(this.getX()-2 &lt; 1 || this.getY()-1 &lt;1) return null; return new Point(this.getX()-2,this.getY()-1); &#125; @Override public int hashCode() &#123; int result = 17; result = 31 * result + this.getX(); result = 31 * result + this.getY(); return result; &#125; @Override public boolean equals(Object obj) &#123; if(obj == this) return true; if(!(obj instanceof Point)) return false; if(obj.hashCode()!=this.hashCode()) return false; Point p = (Point) obj; return (p.getY() == this.getY()) &amp;&amp; (p.getX() == this.getX()); &#125;&#125; 我们这里用一个数组保存每个点搜索过的方向，如果这个点搜索过北偏东方向的话，就标为1。回溯之后可以根据这个信息搜索其他方向。 和走迷宫稍有不同的是，一个点可由多个方向抵达，并且抵达后的棋盘状况不一定。所以回溯的时候，要把沿途的点的状态清为0。 当栈的size等于64的时候，就代表所有点都走过且仅走过一遍了。再倒着把每个点的路径标上、输出就ok了。 思路上是这样的，但实际运行的时候发现，8*8的棋盘dfs时间异常长，是得不出结果的。这个做法只能用于较小的棋盘。 最后栈所保存的元素就是路径上的每一个点了。 优化前代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public static int chess[][]=new int[9][9];public static String solveByStack(Point entrance)&#123; Stack&lt;Point&gt; solve = new Stack&lt;&gt;(); chess =new int[9][9]; solve.push(entrance); chess[entrance.getX()][entrance.getY()] = 0; Point pTop; //所有点走过为止 while(solve.size()!=64)&#123; Point qNewTop; pTop = solve.peek(); System.out.println("("+pTop.getX()+"," + pTop.getY()+")"); if(chess[pTop.getX()][pTop.getY()] &lt; 1 &amp;&amp; (qNewTop = pTop.moveNE()) != null &amp;&amp; chess[qNewTop.getX()][qNewTop.getY()] == 0)&#123; chess[pTop.getX()][pTop.getY()] = 1; solve.push(qNewTop); continue; &#125; if(chess[pTop.getX()][pTop.getY()] &lt; 2 &amp;&amp; (qNewTop = pTop.moveEN()) != null &amp;&amp; chess[qNewTop.getX()][qNewTop.getY()] == 0)&#123; chess[pTop.getX()][pTop.getY()] = 2; solve.push(qNewTop); continue; &#125; if(chess[pTop.getX()][pTop.getY()] &lt; 3 &amp;&amp; (qNewTop = pTop.moveES()) != null &amp;&amp; chess[qNewTop.getX()][qNewTop.getY()] == 0)&#123; chess[pTop.getX()][pTop.getY()] = 3; solve.push(qNewTop); continue; &#125; if(chess[pTop.getX()][pTop.getY()] &lt; 4 &amp;&amp; (qNewTop = pTop.moveSE()) != null &amp;&amp; chess[qNewTop.getX()][qNewTop.getY()] == 0)&#123; chess[pTop.getX()][pTop.getY()] = 4; solve.push(qNewTop); continue; &#125; if(chess[pTop.getX()][pTop.getY()] &lt; 5 &amp;&amp; (qNewTop = pTop.moveSW()) != null &amp;&amp; chess[qNewTop.getX()][qNewTop.getY()] == 0)&#123; chess[pTop.getX()][pTop.getY()] = 5; solve.push(qNewTop); continue; &#125; if(chess[pTop.getX()][pTop.getY()] &lt; 6 &amp;&amp; (qNewTop = pTop.moveWS()) != null &amp;&amp; chess[qNewTop.getX()][qNewTop.getY()] == 0)&#123; chess[pTop.getX()][pTop.getY()] = 6; solve.push(qNewTop); continue; &#125; if(chess[pTop.getX()][pTop.getY()] &lt; 7 &amp;&amp; (qNewTop = pTop.moveWN()) != null &amp;&amp; chess[qNewTop.getX()][qNewTop.getY()] == 0)&#123; chess[pTop.getX()][pTop.getY()] = 7; solve.push(qNewTop); continue; &#125; if(chess[pTop.getX()][pTop.getY()] &lt; 8 &amp;&amp; (qNewTop = pTop.moveNW()) != null &amp;&amp; chess[qNewTop.getX()][qNewTop.getY()] == 0)&#123; chess[pTop.getX()][pTop.getY()] = 8; solve.push(qNewTop); continue; &#125; //无路可走 回溯 chess[pTop.getX()][pTop.getY()] = 0; solve.pop(); &#125; System.out.println(solve.size()); while(!solve.isEmpty())&#123; pTop = solve.pop(); chess[pTop.getX()][pTop.getY()] = solve.size()+1; &#125; StringBuffer stringBuffer = new StringBuffer(); for(int i=1;i&lt;9;i++) &#123; for (int j = 1; j &lt; 9; j++) &#123; stringBuffer.append(chess[i][j] +" "); &#125; stringBuffer.append("\r\n"); &#125; return stringBuffer.toString();&#125; 使用贪心（预见算法）优化 贪心优化的思路是：有选择性的走下一个点，先走最难到达的点。 所以我们这里增加了一个新方法 public static int countAccess(Point p) 来计算8个方向中有多少个方向可以到达p点。 然后选择方向的时候以此为标准，先走去最难走的方向，就可以实现优化了。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package lab3.Knight;import java.util.LinkedList;import java.util.Queue;import java.util.Stack;/** * @author AyagiKei * @url https://github.com/Ayagikei **/public class KnightProblemSolve &#123; public static int chess[][][]=new int[9][9][9]; public static String solveByStackWithOpti(Point entrance)&#123; Stack&lt;Point&gt; solve = new Stack&lt;&gt;(); //棋盘数组，计算过程中标记每个点已经走向过的方向 //第三维的[0]代表该点是否走过，[1]~[8]代表相应的方向是否走过 chess = new int[9][9][9]; //起点入栈 solve.push(entrance); //栈顶元素 Point pTop; //所有点走过为止 while(solve.size()!=64)&#123; //栈为空即无解的时候返回null if(solve.isEmpty()) return null; Point pNewTop,chosenPoint = null; int direction = 0,cnt = 9; pTop = solve.peek(); System.out.println("("+pTop.getX()+"," + pTop.getY()+")"); //计算并且找出8个方向中通路最少的路（并且是可以到达的） for(int i=1;i&lt;=8;i++)&#123; if(chess[pTop.getX()][pTop.getY()][i] == 0)&#123; pNewTop = getPoint(pTop, i); if(pNewTop != null &amp;&amp; chess[pNewTop.getX()][pNewTop.getY()][0] == 0)&#123; if(countAccess(pNewTop) &lt; cnt)&#123; cnt = countAccess(pNewTop); direction = 1; chosenPoint = pNewTop; &#125; &#125; &#125; &#125; //cnt == 9的时候就是无路可走的时候，回溯 if(cnt == 9) &#123; for(int i=0;i&lt;9;i++) chess[pTop.getX()][pTop.getY()][i] = 0; solve.pop(); &#125; else&#123; //选择最窄的路先走 chess[pTop.getX()][pTop.getY()][0] = 1; chess[pTop.getX()][pTop.getY()][direction] = 1; solve.push(chosenPoint); &#125; &#125; System.out.println(solve.size()); //反向标记走过的路线 while(!solve.isEmpty())&#123; pTop = solve.pop(); chess[pTop.getX()][pTop.getY()][0] = solve.size()+1; &#125; //输出 StringBuffer stringBuffer = new StringBuffer(); for(int i=1;i&lt;9;i++) &#123; for (int j = 1; j &lt; 9; j++) &#123; stringBuffer.append(chess[i][j][0] +" "); &#125; stringBuffer.append("\r\n"); &#125; return stringBuffer.toString(); &#125; //统计p点的通路（可以到达的） public static int countAccess(Point p)&#123; int cnt = 0; Point pNewPoint; for(int i=1;i&lt;=8;i++)&#123; pNewPoint = getPoint(p, i); if(pNewPoint != null &amp;&amp; chess[pNewPoint.getX()][pNewPoint.getY()][0] == 0) cnt ++; &#125; return cnt; &#125; //获取8个方向的点 private static Point getPoint(Point p, int i) &#123; Point pNewPoint; switch(i)&#123; case 1: pNewPoint = p.moveNE();break; case 2: pNewPoint = p.moveEN();break; case 3: pNewPoint = p.moveES();break; case 4: pNewPoint = p.moveSE();break; case 5: pNewPoint = p.moveSW();break; case 6: pNewPoint = p.moveWS();break; case 7: pNewPoint = p.moveWN();break; case 8: pNewPoint = p.moveNW();break; default:pNewPoint = null; &#125; return pNewPoint; &#125;&#125; 代码以及运行结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374System.out.println(KnightProblemSolve.solveByStackWithOpti(new Point(4,5)));(4,5)(2,6)(1,8)(3,7)(5,8)(7,7)(8,5)(6,6)(7,8)(8,6)(7,4)(8,2)(6,1)(7,3)(8,1)(6,2)(8,3)(7,1)(5,2)(3,1)(1,2)(2,4)(1,6)(2,8)(4,7)(6,8)(8,7)(7,5)(5,6)(4,8)(6,7)(8,8)(7,6)(6,4)(7,2)(8,4)(6,5)(5,7)(3,8)(1,7)(3,6)(5,5)(6,3)(5,1)(4,3)(2,2)(1,4)(3,5)(2,7)(1,5)(2,3)(1,1)(3,2)(4,4)(2,5)(4,6)(5,4)(4,2)(3,4)(5,3)(4,1)(3,3)(2,1)6452 21 64 47 50 23 40 3 63 46 51 22 55 2 49 24 20 53 62 59 48 41 4 39 61 58 45 54 1 56 25 30 44 19 60 57 42 29 38 5 13 16 43 34 37 8 31 26 18 35 14 11 28 33 6 9 15 12 17 36 7 10 27 32 所耗时间仅为20ms。 参考文章 https://blog.csdn.net/sb___itfk/article/details/50905275]]></content>
      <categories>
        <category>技术</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>数据结构</tag>
        <tag>java</tag>
        <tag>查找</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 分别用栈dfs和队列bfs解决走迷宫问题]]></title>
    <url>%2Fpost%2F995edba2.html</url>
    <content type="text"><![CDATA[题目 走迷宫。 一个迷宫如图所示，他有一个入口和一个出口，其中白色单元表示通路，黑色单元表示不通路。试寻找一条从入口到出口的路径，每一部只能从一个白色单元走到相邻的白色单元，直至出口。分别用栈和队列求解问题。 栈的解法 首先写一个Point类来方便保存每个点的xy值，并且方便表示上下左右各个方向的点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * @author AyagiKei * @url https://github.com/Ayagikei **/public class Point &#123; private int x,y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; public Point left()&#123; if(this.getY()==0) return null; return new Point(this.getX(),this.getY()-1); &#125; public Point right()&#123; return new Point(this.getX(),this.getY()+1); &#125; public Point up()&#123; if(this.getX()==0) return null; return new Point(this.getX()-1,this.getY()); &#125; public Point down()&#123; return new Point(this.getX()+1,this.getY()); &#125; @Override public int hashCode() &#123; int result = 17; result = 31 * result + this.getX(); result = 31 * result + this.getY(); return result; &#125; @Override public boolean equals(Object obj) &#123; if(obj == this) return true; if(!(obj instanceof Point)) return false; if(obj.hashCode()!=this.hashCode()) return false; Point p = (Point) obj; return (p.getY() == this.getY()) &amp;&amp; (p.getX() == this.getX()); &#125;&#125; 栈进行dps的思路就是使用回溯法，遇到分岔路的时候，选择一条走到底；若遇到死胡同就回溯到上一个分岔路，选择另外一条路线，直到走到出口为止。 最后栈所保存的元素就是路径上的每一个点了。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static String solveByStack(int maze[][],Point entrance,Point exit)&#123; Stack&lt;Point&gt; solve = new Stack&lt;&gt;(); solve.push(entrance); maze[entrance.getX()][entrance.getY()] = 2; Point p; //找到出口为止 while(!solve.peek().equals(exit))&#123; //System.out.println(solve.peek().getX() + " " + solve.peek().getY()); //上下左右进一格，并将走过的地方标记为2 if(((p = solve.peek().up())!=null) &amp;&amp; maze[p.getX()][p.getY()] == 0)&#123; maze[p.getX()][p.getY()] = 2; solve.push(p); // System.out.println("up"); continue; &#125; p = solve.peek().down(); if((p.getX() &lt; maze.length) &amp;&amp; maze[p.getX()][p.getY()] == 0)&#123; maze[p.getX()][p.getY()] = 2; solve.push(p); // System.out.println("down"); continue; &#125; p =solve.peek().left(); if((p !=null) &amp;&amp; maze[p.getX()][p.getY()] == 0)&#123; maze[p.getX()][p.getY()] = 2; solve.push(p); // System.out.println("left"); continue; &#125; p = solve.peek().right(); if((p.getY() &lt; maze[0].length) &amp;&amp; maze[p.getX()][p.getY()] == 0)&#123; maze[p.getX()][p.getY()] = 2; solve.push(p); // System.out.println("right"); continue; &#125; //无路可走 回溯 solve.pop(); //System.out.println("back"); &#125; //反向标记最终的路线为3 while(!solve.isEmpty())&#123; p = solve.pop(); maze[p.getX()][p.getY()] = 3; &#125; //构建字符串返回 StringBuffer stringBuffer = new StringBuffer(); for(int i=0;i&lt;maze.length;i++) &#123; for (int j = 0; j &lt; maze[0].length; j++) &#123; stringBuffer.append(maze[i][j]); &#125; stringBuffer.append("\r\n"); &#125; return stringBuffer.toString();&#125; 队列的解法 队列同样也要用到Point类，代码同上。 使用队列进行bfs的思路就是，一层层的往下搜索。 具体方法为： (1) 将从入口开始的相邻可通元素入队。 (2) 出队首元素，再将其相邻未曾入队的元素入队。 (3) 重复操作(2)，直到找到出口。 这样就有一个问题：该如何记录路径？ 这里可以采用增加一个数组来保存经过的节点的前驱结点。 最后从出口可以，根据节点的前驱结点就可以找出完整的路径了。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static String solveByQueue(int maze[][],Point entrance,Point exit)&#123; Point [][]mark = new Point[maze.length][maze[0].length]; Queue&lt;Point&gt; queue = new LinkedList&lt;Point&gt;(); //起点的前驱指向自己，并入队 mark[entrance.getX()][entrance.getY()] = entrance; queue.offer(entrance); while(!queue.isEmpty())&#123; Point p = queue.poll(); Point n = p.up(); if( n != null &amp;&amp; maze[n.getX()][n.getY()] == 0 &amp;&amp; mark[n.getX()][n.getY()] == null)&#123; mark[n.getX()][n.getY()] = p; if(n.equals(exit))&#123; break; &#125; queue.offer(n); &#125; n = p.down(); if((n.getX() &lt; maze.length) &amp;&amp; maze[n.getX()][n.getY()] == 0 &amp;&amp; mark[n.getX()][n.getY()] == null)&#123; mark[n.getX()][n.getY()] = p; if(n.equals(exit))&#123; break; &#125; queue.offer(n); &#125; n = p.left(); if((n !=null) &amp;&amp; maze[n.getX()][n.getY()] == 0 &amp;&amp; mark[n.getX()][n.getY()] == null)&#123; mark[n.getX()][n.getY()] = p; if(n.equals(exit))&#123; break; &#125; queue.offer(n); &#125; n = p.right(); if((n.getY() &lt; maze[0].length) &amp;&amp; maze[n.getX()][n.getY()] == 0 &amp;&amp; mark[n.getX()][n.getY()] == null)&#123; mark[n.getX()][n.getY()] = p; if(n.equals(exit))&#123; break; &#125; queue.offer(n); &#125; &#125; //标记路径 Point p = exit; while(p != entrance)&#123; maze[p.getX()][p.getY()] = 3; p = mark[p.getX()][p.getY()]; &#125; maze[p.getX()][p.getY()] = 3; StringBuffer stringBuffer = new StringBuffer(); for(int i=0;i&lt;maze.length;i++) &#123; for (int j = 0; j &lt; maze[0].length; j++) &#123; stringBuffer.append(maze[i][j]); &#125; stringBuffer.append("\r\n"); &#125; return stringBuffer.toString();&#125; 测试代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package lab3.Maze;import org.junit.Assert;import org.junit.Test;import static org.junit.Assert.*;/** * @author AyagiKei * @url https://github.com/Ayagikei **/public class MazeSolveTest &#123; @Test public void solveByStack() &#123; int maze[][] = &#123; &#123;0,1,0,0,0,1&#125;, &#123;0,0,0,1,0,1&#125;, &#123;1,0,1,0,0,1&#125;, &#123;0,0,0,1,1,1&#125;, &#123;0,1,1,0,0,0&#125;, &#123;0,0,0,0,1,1&#125; &#125;; System.out.println(MazeSolve.solveByStack(maze,new Point(0,0),new Point(4,5))); int maze2[][] = &#123; &#123;0,1,0,0,0,1&#125;, &#123;0,0,0,1,0,1&#125;, &#123;1,1,1,0,0,1&#125;, &#123;0,0,0,1,0,1&#125;, &#123;0,1,1,0,0,0&#125;, &#123;0,0,0,0,1,1&#125; &#125;; System.out.println(MazeSolve.solveByStack(maze2,new Point(0,0),new Point(4,5))); &#125; @Test public void solveByQueue() &#123; int maze[][] = &#123; &#123;0,1,0,0,0,1&#125;, &#123;0,0,0,1,0,1&#125;, &#123;1,0,1,0,0,1&#125;, &#123;0,0,0,1,1,1&#125;, &#123;0,1,1,0,0,0&#125;, &#123;0,0,0,0,1,1&#125; &#125;; System.out.println(MazeSolve.solveByQueue(maze,new Point(0,0),new Point(4,5))); int maze2[][] = &#123; &#123;0,1,0,0,0,1&#125;, &#123;0,0,0,1,0,1&#125;, &#123;1,1,1,0,0,1&#125;, &#123;0,0,0,1,0,1&#125;, &#123;0,1,1,0,0,0&#125;, &#123;0,0,0,0,1,1&#125; &#125;; System.out.println(MazeSolve.solveByQueue(maze2,new Point(0,0),new Point(4,5))); &#125;&#125; 参考文章 https://blog.csdn.net/K346K346/article/details/51289478 https://blog.csdn.net/raphealguo/article/details/7523411]]></content>
      <categories>
        <category>技术</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>数据结构</tag>
        <tag>java</tag>
        <tag>查找</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《传送门》中的游戏机制来源--传送门与凝胶]]></title>
    <url>%2Fpost%2F23d68c4e.html</url>
    <content type="text"><![CDATA[本文首发于我的知乎专栏「丹特利安的书架」。另外还发布于 Indienova 及其公众号，以及搜狐新闻的转载。本文受到了知乎的编辑推荐。并且授权了游资网的转载。 序初次接触到《传送门（Portal）》的你，一定会对传送门的设定感觉到新颖。接触到二代，又一定会对凝胶系统感觉兴奋。但其实，这两个游戏机制都不是在《传送门》最先出现的。 让我们先谈谈Valve。 Valve 一直都是一家喜欢招纳人才、吸收游戏创意的公司。 如众所周知的《军团要塞（Team Fortress）》、《反恐精英（Counter-Strike）》原先都只是《半条命（Half-life）》的模组。Valve将这些高质量模组的制作人和游戏纳入麾下，并坚持打磨着这些游戏的设定与玩法，使其臻于完美。 Valve 还有知名度较低的一款作品《异星虫群（Alien Swarm）》，其也是一款由 Valve 从模组社区招聘来的才华四溢的设计小组制作的游戏。 设计小组在进入 Valve 之前就在开发这款游戏，进入 Valve 后获许用 Source 引擎移植这款游戏。游戏免费发布后，也火热了好一段时间。 而传送门和凝胶机制，其实都有原型游戏。 因原型游戏受到 Valve 青睐，游戏的创意和开发团队都因此进入了 Valve 。 传送门的起源——《Narbacular Drop》 《Narbacular Drop》是一款由迪吉彭理工学院的大学生开发的游戏项目。它获得了2006年独立游戏节（the Independent Games Festival）的学生展示优胜奖项。 玩家在游戏中扮演的是一位叫做 “No-Knees” 的公主，正如名字所示，这位公主无法跳跃。公主被一个恶魔抓了起来，随后公主发现自己被关押的地牢其实是一个叫做 Wally 的生物，而 Wally 拥有制作传送门的能力，公主需要依靠这个能力逃出地牢并打败恶魔。 而游戏中的传送门与《传送门》中的传送门的设定十分相似。玩家能将其放置在一些非金属平面上。 同时游戏中还有一些诸如开关、箱子、滚动的巨石等解密元素。 《Narbacular Drop》作为一款概念展示型的游戏，关卡流程极短，只有6个谜题，甚至没有进度保存功能。不过，游戏论坛中也有一些自定义地图可以游玩。 《Narbacular Drop》发布之后，它的理念吸引到了 Valve 。 Valve 随即聘请了整个开发团队。这个开发团队后来进行了《传送门》的开发工作。 两款游戏理念近似： 在《Narbacular Drop》中，目的是逃脱地牢；而在《传送门》中，目的是逃脱实验室。 在《Narbacular Drop》中，有一个唯一的敌人——恶魔；而在《传送门》中，也有唯一的敌人GLaDOS。 如今，你仍能在《Narbacular Drop》的官网下载到这款游戏。 对了，还有一个小彩蛋，《传送门2》中有一个成就就叫做 Narbacular Drop。 凝胶其实源自喷漆——《Tag : The Power of Paint》 游玩过《传送门2》的你，一定会对游戏中的凝胶机制印象深刻。踩上去能让玩家瞬间获得速度的橙色加速凝胶；碰到就会让玩家弹跳的蓝色弹跳凝胶；还有能将不可放置传送门的平面变成可以放置传送门的灰白色凝胶；以及还有起清洗凝胶作用的水。 游戏中的很多谜题需要玩家将凝胶洒向不同的地方来解决。以上图举个例子，玩家可以将蓝色凝胶洒向机枪，将她们弹起来从而瘫痪她们的攻击。 多种凝胶的配合使用解决谜题更是让人心动不已。毫无疑问，凝胶系统的加入让《传送门2》的玩法更加多样化，使谜题的设置得以更加丰富。 《传送门2》的凝胶机制其实是源自一款叫做《给力涂鸦（Tag: The Power of Paint）》的游戏。 《给力涂鸦》同样是一款，由迪吉彭理工学院七个大学生，耗时约18个月开发的作品（没错，与上面所提及的《Narbacular Drop》的开发者们出自同一所大学）。 游戏于 2009 年发布，并获得了同年的独立游戏节的学生展示奖项。 游戏中你将拿着一把喷漆枪在一片灰白的世界尽情喷漆，通过不同喷漆的特殊能力前进，想法设法通过9个城市。 游戏一开始，你只有绿色喷漆。随着游戏的进行，你能搜集到红色和蓝色喷漆。 喷漆枪能喷出3种不同颜色喷漆：绿色喷漆有弹跳功能；红色喷漆有加速功能；蓝色喷漆有黏着功能。 《传送门2》中加入了前两者喷漆的功能。而蓝色喷漆的黏着功能可以让玩家站在垂直平面而不掉落。 当然，喷漆枪还有清除功能，可以喷射白色喷漆清除其他颜色的喷漆。（《传送门2》中的水也有相同的作用。） 游戏赢得独立游戏节的奖项之后，其音乐、谜题和游戏画面与游戏机制的巧妙结合，受到了业界的赞誉。独立游戏节的专栏记者查维斯·法瑟（Travis Fahs）把该游戏称作2009年第二好的独立游戏，并且希望该作能开发出一个完整的商业游戏。GameSpot（一家游戏媒体）称该游戏是《传送门》和《镜之边缘》元素的巧妙结合，并且称赞了游戏的物理引擎表现。 如今，你仍在迪吉彭理工学院的网站上下载到这款游戏** 同样的，游戏开发团队被招聘进了Valve，并参与到了《传送门2》的开发工作之中，为《传送门2》带来了新的解谜要素——凝胶。 当然，《传送门2》并没有照搬《给力涂鸦》的设定——并不会有什么凝胶枪，取而代之的是无限输送凝胶的管道。而将凝胶洒向自己的想要的区域的方式也改成了利用传送门以及其他机关要素（如传送漏斗可以浮空运输凝胶）。 尾读者可以亲自下载上述的两款游戏，体验一番。虽然游戏较为简陋，但也是有一定的游戏性的。 许多小众独立游戏中或有十分具有潜力的游戏创意，但因为各种各样的问题（如创意载体较简陋），而没有被挖掘出创意的真正价值。 希望 Valve 独特的融合游戏要素的方式，能启迪到一些游戏开发者。 最近有一款将传送门要素和桥梁建造要素融合起来的游戏。先不提游戏素质如何，游戏的创意是很赞的。 最后一提，如果你还没完整体验过《传送门》系列（单人、合作剧情，创意工坊等），现在冬季特惠是你购买的好时机。创意工坊中甚至有情人节主题的地图。 如果想体验一段全新的《传送门》剧情，也可以尝试一下一款质量颇佳的Mod 《Portal Stories: Mel》。 Thanks for reading.]]></content>
      <categories>
        <category>游戏</category>
        <category>文化</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>Portal</tag>
        <tag>Valve</tag>
        <tag>文化</tag>
        <tag>机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件安利：手机平板串流（远程控制）电脑]]></title>
    <url>%2Fpost%2F83278669.html</url>
    <content type="text"><![CDATA[串流 指的是通过网络将另一个终端的画面传输过来显示，并且可以将指令传输过去的一种远程控制方式。我们不时可能会有一些串流的需求，在这里推荐几款软件。 Splashtop官网 多平台支持（Windows、macOS、iPad、iPhone、Android、Kindle Fire） 强大的功能，你可以设置串流的终端自动锁屏、黑屏；以及设置声音的播放端等。 支持多种操作手势，在触摸屏上就可以完成电脑所需的多种操作。 收费 AnyDesk官网 完全免费！ 体积极小，Windows端只需要1.9mb 多平台支持（Windows、macOS、linux、FreeBSD、Android、iOS、Raspberry PI） 性能优良、串流速度快 缺少一些高级功能 其他一些类似软件 TeamViewer 向日葵]]></content>
      <categories>
        <category>软件</category>
        <category>安利</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>安利</tag>
        <tag>APP</tag>
        <tag>手机</tag>
        <tag>平板</tag>
        <tag>电脑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 手机通过 SSH 方式连接云服务器]]></title>
    <url>%2Fpost%2F83d18952.html</url>
    <content type="text"><![CDATA[身边没有电脑，只有手机，但又想远程连接服务器进行操作和文件传输，该怎么办呢？ 其实，一些 app 能让你的手机立刻变成一个 linux 终端。 所用的APP Termux 体积小 内置了一个虚拟键盘，可以模拟ESC，CTRL等键盘操作 支持bash和zsh 支持nano和vim 支持多 Session More… 连接服务器1ssh &lt;user name&gt;@&lt;ip address&gt; -p &lt;port&gt; 第一次使用可能要求你安装 ssh 服务。 端口号是必须指定才能连接的，一般 ssh 用的端口是 22。 之后会要求你输入密码，输完密码就进入了云服务器的终端。 下载文件1scp -r &lt;user name&gt;@&lt;ip address&gt;:&lt;file path&gt; &lt;local download path&gt; 例如：scp -r root@192.168.1.1:/root/qrcode.png /storage/emulated/0/download/ 一般 /storage/emulated/0 就是你本地存储空间的根目录。 说好的虚拟键盘 在左边界往右滑动可唤出侧边栏，接着长按 KEYBOARD 按钮就可以了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SSH</tag>
        <tag>云服务器</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目文档：舰C主题的QQ机器人（ QQ Bot Kancolle）]]></title>
    <url>%2Fpost%2F61989d5e.html</url>
    <content type="text"><![CDATA[项目主页：https://github.com/Ayagikei/Kancolle-QQ-Bot 这是基于 ScienJus/smartqq 制作的一个自用的，主题为 舰队Collection 机器人。 更新记录2018/4/25 以栈的方式重写了TwitterGetter方法，现在可以获取一次更新的多条官推。 2018/4/22 现在以Maven的方式导入smartqq，重新设计了项目的包结构。 2018/4/21 增加复读功能（1%几率复读+重复了3次的语句自动复读），官推转发现在可以识别 Img 标签。 现有功能 自动聊天回复。 当收到特定消息的时候，机器人会从 3 句台词中自动选择 1 句进行回复。 整点报时功能。 每到整点的时候，机器人都会发送特定报时语音。 简单的查询 Kancolle 日常特殊日期任务 能自动从kcwiki官推转发转发新的官推，也可以手动查询最新的官推 内置的一个Roll程序，使用方法是发送群信息包含”Roll”、”欧根”以及一个或多个数字。 Cosplay 功能，现在你不修改代码就能更改机器人的台词，并且支持扩展。 复读功能，任意语句（不包含&lt;称呼&gt;）1%几率复读，或者重复了3次的语句自动复读。 使用方法配置好MAVEN环境后，Clone该项目，以Application.java为运行入口运行，使用一个 QQ 小号登陆即可。 或者下载已经编译好的 jar 文件，使用 java -jar smartqq.jar 指令运行。 机器人指令群聊以下指令只需要在一句话中包含这几个关键字即可，并且英文关键字忽视大小写。 查询特殊指令任务：&lt;称呼&gt; + 任务 查询最新官推：&lt;称呼&gt; + 官推 Roll 点数：&lt;称呼&gt; + roll + 一个或多个数字 查询 Cosplay 列表：&lt;称呼&gt; + cosplay列表 Cosplay 角色：&lt;称呼&gt; + cosplay + 角色数字 私聊 刷新群列表：刷新群列表 刷新xml文件解析：xml 查询 Cosplay 列表：cosplay列表 Cosplay 角色：cosplay + 角色数字 自定义角色在项目根目录找到 stringKancolle.xml文件，打开。 ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;kancolle&gt; &lt;role&gt;001&lt;/role&gt; &lt;!-- 默认角色的代号 --&gt; &lt;character id="001" name="Prinz Eugen"&gt; &lt;!-- 角色代号以及名称 --&gt; &lt;at&gt;欧根&lt;/at&gt; &lt;!-- 两个称呼 --&gt; &lt;at2&gt;老婆&lt;/at2&gt; &lt;call1&gt;Einen schönen Tag.&lt;/call1&gt; &lt;!-- 三种回复 --&gt; &lt;call2&gt;哇，吓了我一跳！…啊是！出击！&lt;/call2&gt; &lt;call3&gt;提督！莱茵演习吗！…啊什么啊不是啊…没关系，我会加油的！交给我吧！&lt;/call3&gt; &lt;inf&gt;舰队的情报啊，嗯，稍等哦，哦，哦哦，原来如此呐～ &lt;/inf&gt; &lt;!-- 获取官推的回复 --&gt; &lt;flush&gt;提督~成功刷新了。&lt;/flush&gt; &lt;!-- 角色的报时 --&gt; &lt;time0&gt;哇哇！？正好0点啦！今天是我欧根亲王担任报时娘的角色呢。好，明白啦！交给我吧！&lt;/time0&gt; &lt;time1&gt;凌晨1点到啦！以这样的元气的感觉来说吗？啊，是吗，太好啦！&lt;/time1&gt; &lt;time2&gt;凌晨2点。这个国家称此时为“ushi…mitsu…doki”…吗？啊，总觉得这个短语的发音好有趣呢。&lt;/time2&gt; &lt;time3&gt;哇，吓了我一跳。啊，很在意我这个发型吗？啊啊，已经凌晨3点啦！&lt;/time3&gt; &lt;time4&gt;嗯嗯～～，凌晨4点了，嗯嗯～～不管怎么说是有些困了…但是，没关系的！&lt;/time4&gt; &lt;time5&gt;5点到啦！早上好，好舒服的早晨呢！加油干吧！&lt;/time5&gt; &lt;time6&gt;6点了呢。该吃早饭了啊…诶，我来做？明，明白了，交给我吧！嗯，做什么吃呢。俾斯麦姐姐的一份也要做吧，对吧♪～&lt;/time6&gt; &lt;time7&gt;好，今天的早饭是面包。奶酪和香肠哦。还有沙拉和…当然，热乎乎的咖啡啦！/r/n 虽然普通但是很美味吧♪～啊，现在正好7点整。&lt;/time7&gt; &lt;time8&gt;8点啦。来吧，Admiral先生，开始今天的作战吧！从演习开始？还是说远征？&lt;/time8&gt; &lt;time9&gt;早上9点了。嗯？啊，是长门啊！喂♪～长～门♪～…嗯？在哪儿遇见的？那当然是～\r\n …嗯…诶？在，在哪儿来着…&lt;/time9&gt; &lt;time10&gt;10点了。战列舰？没问题！和俾斯麦姐姐在一起的话，完～全不用全力就能击沉呢！交给我吧♪～&lt;/time10&gt; &lt;time11&gt;午前11点啦♪～差不多该吃午饭了呢。今天的话，在外面吃也挺好的呢。&lt;/time11&gt; &lt;time12&gt;啊啊，已经中午了！正午了呢！午饭的话，在外面吃吃奶酪加面包也不错吧？心情好的话啤酒也来一发吗♪～啊，不行啊…&lt;/time12&gt; &lt;time13&gt;13点了。午后作战开始了呢、加油干吧！&lt;/time13&gt; &lt;time14&gt;14点了。诶，什么什么，酒匂？啊啊，我知道，那只可爱的轻巡吧。&lt;/time14&gt; &lt;time15&gt;15点了。啊，这个吗？是的，这是“瑟布鲁斯”行动作战时的舰装。怎么样，合适我吧♪～&lt;/time15&gt; &lt;time16&gt;16点了。哇，吓我一跳，是俾斯麦姐姐♪～我们一起出击吧！嗯，一定哦！&lt;/time16&gt; &lt;time17&gt;17点了。到黄昏了呢。差不多，今天的太阳也要落下了呢。…哇，漂亮的天空…啊啊，当然俾斯麦姐姐才是最漂亮的♪～&lt;/time17&gt; &lt;time18&gt;18点了。我去准备晚饭了。今天吃生冷食品怎么样？诶，不要？温热的食物比较好？&lt;/time18&gt; &lt;time19&gt;19点了。那么，晚饭我试着做了德国猪肘子加浓汤。汤里透出的味道不错吧？\r\n 最后，在其中加入米饭如同杂烩一样非常美味哦♪～&lt;/time19&gt; &lt;time20&gt;20点到了。日本的重巡们也过的非常的充实呢。嗯嗯，嗯～原来如此…嗯、嗯…&lt;/time20&gt; &lt;time21&gt;21点了。诶，我有什么拿手好戏？嗯，让我想想，曾经，我用舰炮好好的教训了一群蜂拥而至的坦克。这个我出人意料的很在行呢！对！&lt;/time21&gt; &lt;time22&gt;完全已经是晚上了呢，22点了。Admiral先生，今天一天的作战真是辛苦您了！&lt;/time22&gt; &lt;time23&gt;23点了。嗯～～差不多我也要去休息了呢…晚安…诶，不行吗？&lt;/time23&gt; &lt;quest1&gt;Guten Morgen! 提督，今天有5补给舰任务。&lt;/quest1&gt; &lt;quest2&gt;Guten Morgen! 提督，今天有3空母任务。&lt;/quest2&gt; &lt;quest3&gt;Guten Morgen! 提督，今天没有日期尾数特殊任务。&lt;/quest3&gt; &lt;roll&gt;提督，你输入的数字有不在范围内的。（1~100）&lt;/roll&gt; &lt;/character&gt; &lt;/kancolle&gt; 每个 character 部分为一个角色的所有台词，所以增加角色只需要类似的在最后的一个 &lt;/character&gt; 和 中插入新的角色即可。 注意：机器人回复的语句也在自己的检查范围内，尽量不要在回复的语句中加入自己的&lt;称呼&gt; 需要的改进 更多的功能实现 单元测试 二维码直接在控制台输出 网页后台，可供服务器使用 特殊命令加入密码限制 xml优化 部分实现XML解析：dom4j 报时：Quartz]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>项目</tag>
        <tag>QQ机器人</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz的简单介绍与实例应用：整点报时]]></title>
    <url>%2Fpost%2F5dc888ab.html</url>
    <content type="text"><![CDATA[自己弄的一个 QQ 机器人有一个整点报时的功能，当时使用了非常简陋的方法实现。想要重写的时候，发现了一款非常好用的任务调度框架：Quartz。 简单的说，你可以使用 Quartz 轻易地实现类似以下功能： 每隔一段时间执行 每天的特定时间点执行 每月的特定某天的时间点执行 每周几执行 ​ 而且你只需要编写一条表达式就可以按照你设定的日历触发你指定的任务。 下载官网 可以选择下载 jar 包导入项目 或是添加以下 Maven 依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt; 实现任务类Quartz 执行的任务必须是实现了 org.quartz.Job接口的类，该接口只有唯一一个方法 execute(JobExecutionContext arg0) throws JobExecutionException 需要实现。 12345678910111213141516import java.text.SimpleDateFormat;import java.util.Date;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;public class myJob implements Job &#123; @Override public void execute(JobExecutionContext arg0) throws JobExecutionException &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); System.out.println(sdf.format(new Date())); &#125;&#125; 创建并执行任务调度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import static org.quartz.CronScheduleBuilder.cronSchedule;import static org.quartz.JobBuilder.newJob;import static org.quartz.TriggerBuilder.newTrigger;import java.text.SimpleDateFormat;import java.util.Date;import org.quartz.CronTrigger;import org.quartz.JobDetail;import org.quartz.Scheduler;import org.quartz.SchedulerFactory;import org.quartz.impl.StdSchedulerFactory;public class Test &#123; public void go() throws Exception &#123; // 首先，从 SchedulerFactory 中取得一个 Scheduler 的引用 SchedulerFactory sf = new StdSchedulerFactory(); Scheduler sched = sf.getScheduler(); //jobs可以在scheduled的sched.start()方法前被调用 //将 job 通过 Jobdetail 传给 Scheduler JobDetail job = newJob(HourChimeJob.class) .withIdentity("job1", "group1") .build(); //设置触发方式 这里用到的是 cron 表达式 CronTrigger trigger = newTrigger() .withIdentity("trigger1", "group1") .withSchedule(cronSchedule("0 * * * * ?")) .build(); Date ft = sched.scheduleJob(job, trigger); // 计时器开始 sched.start(); &#125; public static void main(String[] args) throws Exception &#123; Test test = new Test(); test.go(); &#125;&#125; 运行你会发现，控制台每一分钟整秒的时候会打印出一次时间。 你可以直接猜到这是由 (cronSchedule(&quot;0 * * * * ?&quot;) 实现的。 没错，这就是 Cron 表达式。 Cron 表达式Cron 表达式包含着由空格分开的多个子表达式。 从左到右分别代表的是 Seconds（秒） Minutes（分） Hours（时） Day-of-Month（日） Month （月） Day-of-Week（周几） Year（年，可选） 并且表达式允许使用一些特殊符号指代一些特殊含义。 字段名 允许数值 允许的符号 Seconds（秒） 0-59 , - * / Minutes（分） 0-59 , - * / Hours（时） 0-23 , - * / Day-of-Month（日） 1-31 , - * ? / L W C Month （月） 1-12 或者 JAN-DEC , - * / Day-of-Week（周几） 1-7 或者 SUN-SAT , - * ? / L C # Year（年，可选） 空 或者 1970-2099 , - * / 特殊符号的含义： “?”字符：表示不确定的值 “,”字符：指定数个值 “-”字符：指定一个值的范围 “/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m。 “L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X。 “W”字符：指定离给定日期最近的工作日（周一到周五） “#”字符：表示该月第几个周X。6#3表示该月第3个周五 整点报时由上易知，整点报时只需要将 Cron 表达式改成 &quot;0 0 * * * ?&quot; ，即只在0分0秒的时候触发执行任务类，也就是整点了。 参考链接 http://www.cnblogs.com/sunjie9606/archive/2012/03/15/2397626.html https://www.cnblogs.com/monian/p/3822980.html http://blog.csdn.net/u010648555/article/details/54863394]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Quartz</tag>
        <tag>实例</tag>
        <tag>Java</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Steam 夏日特惠？不，是夏日"海豹"。]]></title>
    <url>%2Fpost%2Fd16687dc.html</url>
    <content type="text"><![CDATA[本文首发于我的知乎专栏「丹特利安的书架」。 亦授权了小黑盒平台的转载。 其实 “海豹” 指的就是“特惠”、”特卖”。 至于为什么要这么叫， 事情发生在2011年，Steam贴吧的一位吧友，在Steam官方论坛的一个讨论帖子里，本想询问夏日特惠开始的时间，却手抖把 SALE （折扣，特惠）打成了 SEAL （海豹）。 于是就有了： 夏日海豹，会马上开始吗？ 谁知道确切时间？ 然后这个笔（shou）误戳中了外国人的笑点， 出现了以下各种回复： *我希望它能把一个球平衡放在它的鼻子上！* 我会等待冬季海象的到来。 他们有教海豹新把戏吗(⊙_⊙)? 喂海豹一些鱼，它会更听话。 它最好在冬熊抓到它之前到来。:-P 我很好奇海豹会不会唱《A Kiss from a Rose》？（同名歌手梗） 几个星期前，我去了动物园，那里有海豹。但是那时候是春天。所以没有夏日海豹。 我不想要夏日海豹，我想要夏日白海狮！(＾－＾)V （Pokemon梗） 后续还有各种有意思的回复，并且“夏日海豹”的说法在国内Steam圈内流行了两三年。 但是故事并没有这样结束，Valve员工也注意到这个事件。 于是，海豹，真的海豹，在夏日特惠的数张宣传图片中出现。 而且那一年的万圣节活动，所有 军团要塞2 玩家都收到了一份小礼物： 是的，一个海豹面具。 那一年的万圣节特卖，也能在宣传图片中，看到一个 Steam 的吉祥物戴着这个海报面具。 甚至Valve还推出了海豹 T-shirt ： 看到文末的诸位，祝你们下次特惠…哦不，海豹剁手愉快~ 附： 官方论坛帖子链接 夏日海豹面具Wiki页面]]></content>
      <categories>
        <category>游戏</category>
        <category>文化</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>游戏文化</tag>
        <tag>知乎专栏</tag>
        <tag>Steam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩法的再演绎（1）：那些现象级游戏的前身]]></title>
    <url>%2Fpost%2F30824299.html</url>
    <content type="text"><![CDATA[本文首发于我的知乎专栏「丹特利安的书架」。 这篇文章将谈谈三对核心玩法十分相近的游戏。 因核心玩法与其他游戏相似，不少游戏，甚至一部分热门游戏都陷入了”到底是致敬模仿还是无耻抄袭“的争论之中。 但是，一款游戏的开发，或有意识、或无意识地受到他方的影响。到底是“致敬”还是“模仿”的判断点不应局限在一处。单纯的核心玩法相同，但别有创新之作，不应被列入“抄袭”。 好了，不偏题了~。现在来介绍一些现象级（或者稍微比较知名的）游戏的前身： ▊「Angry Birds」与 「Crush the Castle」 《愤怒的小鸟 Angry Birds》一经发布就成为一大现象级作品，名声大噪之后又发布了许多衍生物。它的前身可谓是各种弹弓小游戏。这里着重介绍一款内容比较完善、玩法非常相似的 Flash 游戏《摧毁城堡 Crush the Castle》。 这两款游戏的玩法都是利用抛掷物和物理作用压死所有的敌人，并且随着游戏的进行，解锁不同的抛掷物。 一些不同点： 操作方式上，《愤怒的小鸟》是拖拽松手，而《摧毁城堡》是一次点击启动投石车，另一次单击释放石头（或其他奇怪的东西）。 画风上，《愤怒的小鸟》轻快可爱，而《摧毁城堡》是略为写实的中世纪场景。 《愤怒的小鸟》中的不同小鸟具有不同的特殊能力，能在投掷后释放，这增添了游戏的可操作性。 《摧毁城堡》第二作内置关卡编辑器。 我个人认为，本身就契合触摸操控的游戏玩法、轻松可爱的画面风格以及大气爽快的分数显示，是促成《愤怒的小鸟》成功的要义。《愤怒的小鸟》的游戏模式并不新奇，但其能把这种游戏模式包裹在一个合适的外壳内，并加入一些创新设计，就已经是一种成功了。同样，拥有相同或相似游戏玩法的游戏，并非没有游玩的价值。发掘特色之处，说不定你会爱上另一款作品。 注1：《愤怒的小鸟》如今是一款多平台游戏，本文讨论的是移动端。 注2：《摧毁城堡》已经移植到了移动端，本文讨论的是Flash版。 ▊「Plague Inc」与 「Pandemic 2」 两款游戏的核心玩法十分相似：病原体传染获得进化点，利用进化点选择提升病原体的传染性、致命性和严重性（可视性）。并且在疫苗研制成功之前杀死全人类。基本上可以把《瘟疫公司 Plague Inc. 》看做《Pandemic 2》的高清重制版。 当然，《瘟疫公司 Plague Inc 》在《Pandemic 2》的基础上也进行了一些修改： 《瘟疫公司》可以自己选择病原体初现的国家或地区，而《 Pandemic 2 》则是系统随机选择一个。（于是就出现了下图） （图出处见右下角水印） 《瘟疫公司》需要自己点击地图上出现的气泡获得进化点，而《 Pandemic 2 》是自动获得的。《瘟疫公司》增加了更多的疾病类型，剧情，可进化的症状。 《瘟疫公司》PC版增加了多人模式、内容制作器等等内容。 如今在《瘟疫公司》的Steam社区搜索“**Pandemic” 也能见到一些吐槽称《瘟疫公司》为高清版**的《Pandemic》的帖子。但是我们不得不承认，正是《瘟疫公司》才让更多的人接触到这种游戏玩法。 注1：《瘟疫公司》开发者曾提到过 “Inspired by Pandemic“ （游戏灵感来自于《Pandemic》）。 ▊「This is the only level too」与 「That Level again」 鉴于篇幅问题，第三对游戏，我们就来谈谈一对比较小众的游戏： 《还是只有这一关 This is the only level too》是一款玩法十分有新意的 Flash 解谜游戏。游戏目的很简单，控制小象到达右边的管道。虽然游戏的每一关都看似一样，但是过关方法都略有差异或千差万别。当然了，每一关都会提供跟过关方式有关的关键词。 《又是这关 That Level again》的主要玩法跟《还是只有这一关》基本一致。只不过游戏平台从PC端变成了手机端。同时游戏也根据手机的性质（触摸屏、重力感应等等）设置了一些新的通关方式。这也降低了这两款游戏的体验重叠程度。 即便你已经玩通了《还是只有这一关》，玩《又是这关》也会是一场全新的游戏体验，也同样会使你抓耳挠腮。 ▊「后记」这是我第一篇发布在知乎专栏上的文章。 题图用的是一个叫做Collageit的软件拼接而成，个人觉得还是很好看的XD。 最终文章受到的关注量虽不多，但收到了知友的赞赏，还吸引到了一些网站相关工作人员的目标，颇为受宠若惊。 也是后面几篇专栏文章的重要动力来源 :) （虽然更新不是一般的慢._.）]]></content>
      <categories>
        <category>游戏</category>
        <category>文化</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>游戏文化</tag>
        <tag>知乎专栏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下配置hexo实现个人博客]]></title>
    <url>%2Fpost%2F49d119d7.html</url>
    <content type="text"><![CDATA[1.前言很久以前自己就想要一个自己的博客，来保存自己写过的杂七杂八的文章。偶然间听说用hexo搭建个人博客很简便，就查询了一波资料搭建出了这个网站。第一篇文章就献给hexo的搭建过程吧~ 本文将包括以下部分内容： 所需环境的安装和配置（Git，Node.js） hexo的安装和运行 hexo个性化配置 搭桥Github Pages 绑定个人域名 部署优化 开写吧 2. 所需环境的安装和配置Git的安装 下载地址 安装步骤：如不懂选项可以全程 next 验证：安装完毕后，在任一文件夹空白处右键会多出Git Bash here选项，点开之后输入1$ git -v 若出现git version就代表安装成功。 Node.js的安装 下载地址 安装步骤：同上。注意在 Custom Setup 一步最好勾上 Add to PATH选项。 验证：安装完毕后，在bash中输入1$ node -v 若出现版本号就代表安装成功。 3. hexo的安装和运行正常步骤 打开一个你想存放博客的文件夹，右键Git Bash here。 安装hexo 1$ npm install hexo-cli -g 初始化博客（ 为新建的文件夹名，自行替换） 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 安装服务器模块 1$ npm install hexo-server --save 运行服务器 1$ hexo server --debug Hello hexo！打开 http://localhost:4000 ，你会发现你的博客已经构建完成了！一个坑 npm 过程中卡住 由于 npm 的服务器问题，国内连接不稳定。 可以尝试通过淘宝的镜像服务器解决。 1$ npm config set registry https://registry.npm.taobao.org 再或者更换网络，比如使用手机网络。 4. hexo个性化配置看到自己构建好的博客后，是不是很想将博客换成自己想要的名字？如果你不中意默认的主题的话，还可以自己挑选喜欢的主题。 简单的个性化配置打开博客所在根目录的 _config.yml 文件，我们在此将这个文件叫做 站点配置文件 。可以看到这么一段12345678# Sitetitle: #填上你想要的博客名subtitle: #副标题description: #描述keywords:author: #你的大名language: #简体中文的话可以在这里填上&quot;zh-CN&quot;timezone: 注意一个坑： 每一行的冒号之后记得加上一个空格，否则会报错。 更换 hexo 主题首先你要找到心怡的主题，可以在这里找。 这里推荐一款叫做 NexT 的极简风格的主题，也是本博客使用的主题： 建议直接查阅 NexT 官网 ，安装步骤以及各种自定义步骤十分详细。 注意： NexT主题的GitHub地址在6.0版本之后迁移到了 https://github.com/theme-next/hexo-theme-next 。一些旧博文里的NexT主题的安装方式可能会让你安装上旧版本的NexT主题。 实现 NexT 主题圆形头像在 \themes\NexT\source\css_custom 里的 custom.styl 文件是让我们放入自定义css样式的。我们可能用此文件来实现圆形头像。打开文件并在其中插入1234567.site-author-image &#123; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf;&#125; 5. 搭桥Github Pages在以上方式搭建的服务器只有自己才能访问到，那么如何让其他人也能访问到自己的博客呢？我们将用到Github Pages服务。 Github Pages是什么？ Github Pages 可以托管用户编写的静态网页，还能提供一个域名给用户，更重要的是，还是免费的！ SSH 配置 首先，你要有一个Github账号。 随后，配置本地 git 以 SSH 方式连接 Github。 12$ git config --global user.name "&lt;你的github账号名&gt;"$ git config --global user.email "&lt;你的github邮箱&gt;" 接下来输入以下命令 1$ ssh-keygen -t rsa 然后回车三次，之后就会生成两个文件，分别为id_rsa和id_rsa.pub，即密钥id_rsa和公钥 id_rsa.pub 。 在 https://github.com/settings/keys 中点击 New SSH key，粘贴到刚才生成的 id_rsa.pub 文件其中的内容。 添加完毕后，可以在 Git Bash 里面输入以下命令来测试是否连接成功。 1ssh -T git@github.com 若显示以下内容就表示你已经成功了！ Hi &lt;你的用户名&gt;! You’ve successfully authenticated , but Github does not provide shell access. 建立一个 Github Pages 仓库，并将你的博客上传 在 Github 新建一个名称为 &lt;你的github用户名&gt;.github.io 的仓库。 安装 hexo-deployer-git。 1$ npm install hexo-deployer-git --save 打开博客所在根目录的 _config.yml 文件，即 站点配置文件 。 找到以下段落并修改： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type : git repository : git@github.com:&lt;替换成你的用户名&gt;/&lt;替换成你的用户名&gt;.github.io.git branch : master 在博客根目录打开Git Bash，输入12hexo ghexo d 执行完命令后，你的博客就已经部署在了Github Pages上了。对应的地址是 &lt;替换成你的用户名&gt;.github.io 现在，所有人都可以通过这个地址访问你的邮箱了！ 6. 绑定个人域名但是，如果你想要一个自己设定的域名的话，又该怎么办呢？这里以 万网 为例。 首先，当然是先要购买一个域名啦。在首页查询自己想要的域名，如果没人占用的话就可以买下来了。 其次，对你的域名进行实名认证。此处只需要提供身份证的照片，再等侯一会即可。（几个小时内就能审核完毕）。 然后，如图配置域名解析。 最后，还要在你的本地博客文件夹/Source文件夹内，新建一个无后缀名的叫做CNAME的文件，并在其中写入你的域名。 试试用你的域名访问吧~ 7. 部署步骤优化以上方式只是将 hexo 生成的静态网页上传到 Github Pages，但是并没有备份源文件。这样对于多部电脑编辑博客是件麻烦事，而且文件没有云备份也不安全。当然，你可以新建一个仓库专门用来保存源文件。但是每次变动要上推两个仓库的变动也不方便。 此处，我们将采用在 Github Pages 的仓库中新建一个分支的方式来保存源文件。 首先，打开 Github，在你的 Github Pages 仓库中建立一个新分支 hexo。 然后，在设置将 hexo 设为 Default branch。 在本地另找一个文件夹，进入 Git Bash： 1$ git clone git@github.com:&lt;你的github用户名&gt;/&lt;你的github用户名&gt;.github.io.git 在clone下来的文件夹中删除除了 .git 文件夹之外的其他文件。 将之前的本地博客文件夹里的所有内容复制过来。 进入 Git Bash，你会发现该仓库正处在 hexo 分支状态，输入以下命令： 123$ git add .$ git commit -m "初始化hexo分支"$ git push 这样一来，你 Github 上的仓库就有两个分支，原本的 master 分支保存静态网页；新的 hexo 分支用来保存源文件。 在这之后部署的话，照常使用以下命令来部署静态文件即可。12hexo ghexo d 然后再使用以下Git命令来上推备份原文件。123$ git add .$ git commit -m "初始化hexo分支"$ git push 同时，你还可以编写一份.sh脚本文件来方便自己的部署和git操作；以下是我的脚本代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354echo "Script Starting"echo "----Cleaning"hexo cleanecho "----Generating"hexo gread -r -p "Do u want to run server to debug? [Y/else] " inputcase $input in [yY][eE][sS]|[yY]) echo "----Starting server in debug mode" hexo s --debug ;; *) echo "Skip server" ;;esacread -r -p "Do u want to Deploying? [Y/else] " inputcase $input in [yY][eE][sS]|[yY]) echo "----Deploying" hexo d ;; *) echo "Skip deploy..." ;;esacread -r -p "Do u want to git push? [Y/else] " inputcase $input in [yY][eE][sS]|[yY]) echo "----Git Add" git add . echo "----Git Commit" git commit -m "Update" echo "----Git Push" git push ;; *) echo "Skip git push..." ;;esacecho "All Finaish!"read -p "Press any key to exit." var 8. 开写吧！生成 md 文件使用以下命令生成md文件。1$ hexo new [layout] &lt;title&gt;. 然后再在 source_posts 里找到md文件。可以在头部写入文章的标签以及分类。下面就用正常的 markdown 语法进行编辑即可。 注意： 如果 title包含空格的话，需要用引号括起来。 本地 Markdown 编辑器推荐两款： Cmd Markdown 多平台，还可以在线使用 两栏对比，实时同步预览 编辑器易用 有云同步 需要注册使用 部分功能需要会员 Typora 多平台 实时渲染写好的Markdown代码 编辑器简洁美观 免费支持多种格式导出 体积有些庞大 后台管理编辑插件有两款实现了WEB UI的后台管理编辑插件可供你选择。这里就不对两者的使用方法做介绍了。 Hexo Admin Hexo Local Admin 最后强烈建议读读 hexo 的官方文档以及你所用主题的官方文档。就如 hexo 3.x 有一些自定义标签（插入图片），不同于 markdown 的标准语法。这些都是需要你看看官方文档才能得知的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
